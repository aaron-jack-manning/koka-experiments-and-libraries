/* Core functions.

   This module is implicitly imported and all functions and types
   are always available.
   Some types and operations are required to be defined for the compiler
   to work correctly (i.e. types like `:exn` or `:list`)
*/
module interface std/core
 
//------------------------------
//#kki: import declarations
 
public import std/core/types = std/core/types = "";
public import std/core/hnd = std/core/hnd = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
infixr 80 (^);
infixl 70 (*);
infixl 70 (%);
infixl 70 (/);
infixl 70 cdiv;
infixl 70 cmod;
infixr 60 (++);
infixl 60 (+);
infixl 60 (-);
infix 40 (!=);
infix 40 (==);
infix 40 (<=);
infix 40 (>=);
infix 40 (<);
infix 40 (>);
 
//------------------------------
//#kki: local imported aliases
 
// Stateful funs can manipulate heap `:h` using allocations, reads and writes.
local alias std/core/types/st<(h :: H)> :: H -> E = <(std/core/types/read :: H -> X)<(h :: H)>,(std/core/types/write :: H -> X)<(h :: H)>,(std/core/types/alloc :: H -> X)<(h :: H)>> = 1;
 
//------------------------------
//#kki: type declarations
 
// Exception information
public open type exception-info {
  public con ExnError : exception-info;
  public con ExnAssert : exception-info;
  public con ExnTodo : exception-info;
  public con ExnRange : exception-info;
  public con ExnPattern(location: std/core/types/string, definition: std/core/types/string) : (location : std/core/types/string, definition : std/core/types/string) -> exception-info;
  public con ExnSystem(errno: std/core/types/int) : (errno : std/core/types/int) -> exception-info;
  public con ExnInternal(name: std/core/types/string) : (name : std/core/types/string) -> exception-info;
};
// The exception data type
public value{0,2} type exception {
  // The exception data type
  public con Exception(message: std/core/types/string, info: exception-info) : (message : std/core/types/string, info : exception-info) -> exception;
};
// handlers for the `:exn` effect
public recursive type .hnd-exn <(e :: E),a> :: (E, V) -> V {
  public con .Hnd-exn(brk-throw-exn: forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exception,b,(.hnd-exn :: (E, V) -> V),(e :: E),a>) : forall<(e :: E),a> (brk-throw-exn : forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exception,b,(.hnd-exn :: (E, V) -> V),(e :: E),a>) -> (.hnd-exn :: (E, V) -> V)<(e :: E),a>;
};
// The `:blocking` effect signifies that a function may block
public type blocking :: X ;
// The console effect signifies that a function may write to the console.
public type console :: X ;
// Delayed (or _lazy_) values are computed (with effect `:e`) only the first time
// `force` is called and cached afterwards.
public value{0,1} type delayed <(e :: E),a> :: (E, V) -> V {
  private con Delay(dref: (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>) : forall<(e :: E),a> (dref : (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>) -> (delayed :: (E, V) -> V)<(e :: E),a>;
};
// An `:error` type represents a first-class exception result.
public value{0,2} type error <a> :: V -> V {
  public con Error(exception: exception) : forall<a> (exception : exception) -> (error :: V -> V)<a>;
  public con Ok(result: a) : forall<a> (result : a) -> (error :: V -> V)<a>;
};
// Exceptions
public type exn :: HX {
  private con Exn<(e :: E),a>((.hnd-exn :: (E, V) -> V)<(e :: E),a>) : forall<(e :: E),a> ((.hnd-exn :: (E, V) -> V)<(e :: E),a>) -> (exn :: HX);
};
// The `:fsys` effect signifies a function may access the file system
public type fsys :: X ;
// The `:global-scope` is a special type constant to denote the global scope
public type global-scope :: S ;
// The `:net` effect signifies a function may access the network
public type net :: X ;
// The `:ui` effect signifies a function may access the graphics system
public type ui :: X ;
// The `:io-total` effect is used for functions that perform arbitrary I/O operations, but are terminating without raising exceptions.
public alias io-total :: E = <(std/core/types/ndet :: X),(console :: X),(net :: X),(fsys :: X),(ui :: X),((std/core/types/st :: H -> E)<(std/core/types/global :: H)> == 1 <(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/types/write :: H -> X)<(std/core/types/global :: H)>,(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>>)> = 2;
// The `:io-noexn` effect is used for functions that perform arbitrary I/O operations, but raise no exceptions
public alias io-noexn :: E = <(std/core/types/div :: X),((io-total :: E) == 2 <(std/core/types/ndet :: X),(console :: X),(net :: X),(fsys :: X),(ui :: X),((std/core/types/st :: H -> E)<(std/core/types/global :: H)> == 1 <(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/types/write :: H -> X)<(std/core/types/global :: H)>,(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>>)>)> = 3;
// The `:io` effect is used for functions that perform arbitrary I/O operations.
public alias io :: E = <(std/core/types/handled :: HX -> X)<(exn :: HX)>,((io-noexn :: E) == 3 <(std/core/types/div :: X),((io-total :: E) == 2 <(std/core/types/ndet :: X),(console :: X),(net :: X),(fsys :: X),(ui :: X),((std/core/types/st :: H -> E)<(std/core/types/global :: H)> == 1 <(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/types/write :: H -> X)<(std/core/types/global :: H)>,(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>>)>)>)> = 4;
// The type of lists, which can be either empty (`Nil`) or an element followed
// by a list (`Cons`).
public recursive type list <a> :: V -> V {
  // The empty list.
  public con Nil : forall<a> (list :: V -> V)<a>;
  // A ``head``  element followed by the ``tail``  of the list.
  public con Cons(head: a, tail: (list :: V -> V)<a>) : forall<a> (head : a, tail : (list :: V -> V)<a>) -> (list :: V -> V)<a>;
};
// The `:named` effect is the default umbrella effect for named effects
public type nmd :: X ;
// Abstract type used for passing `null` values to external functions
public type null <a> :: V -> V ;
// An alias for pure effects: a pure function always returns the same result
// when called with the same arguments but may not terminate or raise an exception.
public alias pure :: E = <(std/core/types/handled :: HX -> X)<(exn :: HX)>,(std/core/types/div :: X)> = 1;
public type scope <(s :: S)> :: S -> X ;
// A `:sslice` represents a sub-slice of string and
// has a specific start position and character count. It is used
// instead of string indices to make the actual internal representation
// of strings abstract (like UTF-8 or UTF-16). String slices are
// returned by functions that find sub strings or patterns in
// in strings. Use `string:(slice : sslice) -> string` to
// create a fresh substring from a slice.
public value{16,1} type sslice {
  // A `:sslice` represents a sub-slice of string and
// has a specific start position and character count. It is used
// instead of string indices to make the actual internal representation
// of strings abstract (like UTF-8 or UTF-16). String slices are
// returned by functions that find sub strings or patterns in
// in strings. Use `string:(slice : sslice) -> string` to
// create a fresh substring from a slice.
  private con Sslice(str: std/core/types/string, start: std/core/types/ssize_t, len: std/core/types/ssize_t) : (str : std/core/types/string, start : std/core/types/ssize_t, len : std/core/types/ssize_t) -> sslice;
};
// A `:stream` is a co-inductive type representing an infinite list of elements.
public recursive co type stream <a> :: V -> V {
  public con Next(head: a, tail: (stream :: V -> V)<a>) : forall<a> (head : a, tail : (stream :: V -> V)<a>) -> (stream :: V -> V)<a>;
};
// An alias for the empty effect.
public alias total :: E = (std/core/types/(<>) :: E) = 1;
// TODO: revisit value codegen
public alias value<a> :: V -> V = a = 1;
 
//------------------------------
//#kki: declarations
 
// Automatically generated. Tests for the `ExnError` constructor of the `:exception-info` type.
public fun is-exnError : (^ exception-info : exception-info) -> std/core/types/bool;
// Automatically generated. Tests for the `ExnAssert` constructor of the `:exception-info` type.
public fun is-exnAssert : (^ exception-info : exception-info) -> std/core/types/bool;
// Automatically generated. Tests for the `ExnTodo` constructor of the `:exception-info` type.
public fun is-exnTodo : (^ exception-info : exception-info) -> std/core/types/bool;
// Automatically generated. Tests for the `ExnRange` constructor of the `:exception-info` type.
public fun is-exnRange : (^ exception-info : exception-info) -> std/core/types/bool;
// Automatically generated. Tests for the `ExnPattern` constructor of the `:exception-info` type.
public fun is-exnPattern : (^ exception-info : exception-info) -> std/core/types/bool;
// Automatically generated. Tests for the `ExnSystem` constructor of the `:exception-info` type.
public fun is-exnSystem : (^ exception-info : exception-info) -> std/core/types/bool;
// Automatically generated. Tests for the `ExnInternal` constructor of the `:exception-info` type.
public fun is-exnInternal : (^ exception-info : exception-info) -> std/core/types/bool;
public val .tag-ExnError : std/core/types/string;
public val .tag-ExnAssert : std/core/types/string;
public val .tag-ExnTodo : std/core/types/string;
public val .tag-ExnRange : std/core/types/string;
public val .tag-ExnPattern : std/core/types/string;
public val .tag-ExnSystem : std/core/types/string;
public val .tag-ExnInternal : std/core/types/string;
// Automatically generated. Retrieves the `message` constructor field of the `:exception` type.
public fun message : (^ exception : exception) -> std/core/types/string;
// Automatically generated. Retrieves the `info` constructor field of the `:exception` type.
public fun info : (^ exception : exception) -> exception-info;
public fun .copy : (.this : exception, message : (std/core/types/optional :: V -> V)<std/core/types/string>, info : (std/core/types/optional :: V -> V)<exception-info>) -> exception;
// Automatically generated. Retrieves the `dref` constructor field of the `:delayed` type.
private fun dref : forall<(e :: E),a> (^ delayed : (delayed :: (E, V) -> V)<(e :: E),a>) -> (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>;
public fun .copy.1 : forall<(e :: E),a> (.this : (delayed :: (E, V) -> V)<(e :: E),a>, dref : (std/core/types/optional :: V -> V)<(std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>>) -> (delayed :: (E, V) -> V)<(e :: E),a>;
// Automatically generated. Tests for the `Error` constructor of the `:error` type.
public fun is-error : forall<a> (^ error : (error :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Tests for the `Ok` constructor of the `:error` type.
public fun is-ok : forall<a> (^ error : (error :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Tests for the `Nil` constructor of the `:list` type.
public fun is-nil : forall<a> (^ list : (list :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Tests for the `Cons` constructor of the `:list` type.
public fun is-cons : forall<a> (^ list : (list :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Retrieves the `str` constructor field of the `:sslice` type.
private fun str : (^ sslice : sslice) -> std/core/types/string;
// Automatically generated. Retrieves the `start` constructor field of the `:sslice` type.
private fun start : (^ sslice : sslice) -> std/core/types/ssize_t;
// Automatically generated. Retrieves the `len` constructor field of the `:sslice` type.
private fun len : (^ sslice : sslice) -> std/core/types/ssize_t;
public fun .copy.2 : (.this : sslice, str : (std/core/types/optional :: V -> V)<std/core/types/string>, start : (std/core/types/optional :: V -> V)<std/core/types/ssize_t>, len : (std/core/types/optional :: V -> V)<std/core/types/ssize_t>) -> sslice;
// Automatically generated. Retrieves the `head` constructor field of the `:stream` type.
public fun head : forall<a> (^ stream : (stream :: V -> V)<a>) -> a;
// Automatically generated. Retrieves the `tail` constructor field of the `:stream` type.
public fun tail : forall<a> (^ stream : (stream :: V -> V)<a>) -> (stream :: V -> V)<a>;
public fun .copy.3 : forall<a> (.this : (stream :: V -> V)<a>, head : (std/core/types/optional :: V -> V)<a>, tail : (std/core/types/optional :: V -> V)<(stream :: V -> V)<a>>) -> (stream :: V -> V)<a>;
// select `throw-exn` operation out of the `:exn` effect handler
public fun .select-throw-exn : forall<a,(e :: E),b> (^ hnd : (.hnd-exn :: (E, V) -> V)<(e :: E),b>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exception,a,(.hnd-exn :: (E, V) -> V),(e :: E),b>;
// runtime tag for the `:exn` effect
public val .tag-exn : (std/core/hnd/htag :: ((E, V) -> V) -> V)<(.hnd-exn :: (E, V) -> V)>;
// handler for the `:exn` effect
public fun .handle-exn : forall<a,(e :: E),b> (cfc : std/core/types/int32, hnd : (.hnd-exn :: (E, V) -> V)<(e :: E),b>, ret : (res : a) -> (e :: E) b, action : () -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a) -> (e :: E) b;
// Internal export for the regex module
public fun .new-sslice : (str : std/core/types/string, start : std/core/types/ssize_t, len : std/core/types/ssize_t) -> sslice;
// Unsafe: transform any type to a `null` type; used internally by the compiler.
public fun .null-any : forall<a> (x : a) -> (null :: V -> V)<a>;
private val redirect : (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/maybe :: V -> V)<(std/core/types/string) -> <(console :: X)> ()>>;
// Print a string to the console, including a final newline character.
private fun xprintsln : (s : std/core/types/string) -> <(console :: X)> ();
private fun string-compare : (x : std/core/types/string, y : std/core/types/string) -> std/core/types/int;
// Convert an integer to an `:int32`. The number is _clamped_ to the maximal or minimum `:int32`
// value if it is outside the range of an `:int32`.
public fun int32 : (i : std/core/types/int) -> std/core/types/int32;
// Convert an integer to an `:ssize_t`. The number is _clamped_ to the maximal or minimum `:ssize_t`
// value if it is outside the range of an `:ssize_t`.
public fun ssize_t : (i : std/core/types/int) -> std/core/types/ssize_t;
// Convert a character to a string
public fun string : (c : std/core/types/char) -> std/core/types/string;
// Convert a vector of characters to a string.
public fun string.1 : ((std/core/types/vector :: V -> V)<std/core/types/char>) -> std/core/types/string;
// Convert a list of characters to a string
public fun string.2 : (cs : (list :: V -> V)<std/core/types/char>) -> (total :: E) std/core/types/string;
// O(n). Copy the `slice` argument into a fresh string.
// Takes O(1) time if the slice covers the entire string.
public fun string.3 : (slice : sslice) -> std/core/types/string;
// Convert a `:maybe` string to a string using the empty sting for `Nothing`
public fun string.4 : (ms : (std/core/types/maybe :: V -> V)<std/core/types/string>) -> std/core/types/string;
// Convert a vector to a list with an optional tail.
public fun vlist : forall<a> (v : (std/core/types/vector :: V -> V)<a>, tail : (std/core/types/optional :: V -> V)<(list :: V -> V)<a>>) -> (list :: V -> V)<a>;
private fun int-show-hex : (i : std/core/types/int, use-capitals : std/core/types/bool) -> std/core/types/string;
private fun repeatz : (s : std/core/types/string, n : std/core/types/ssize_t) -> std/core/types/string;
private fun show-expx : (d : std/core/types/double, prec : std/core/types/int32) -> std/core/types/string;
private fun show-fixedx : (d : std/core/types/double, prec : std/core/types/int32) -> std/core/types/string;
// Print a string to the console
private fun xprints : (s : std/core/types/string) -> <(console :: X)> ();
// Raise an integer `i` to the power of `exp`.
public fun pow : (i : std/core/types/int, exp : std/core/types/int) -> std/core/types/int;
// O(`count`). Advance the start position of a string slice by `count` characters
// up to the end of the string.
// A negative `count` advances the start position backwards upto the first position
// in a string.
// Maintains the character count of the original slice upto the end of the string.
// For example:
//
// * `"abc".first.advance(1).string == "b"`,
// * `"abc".first.advance(3).string == ""`,
// * `"abc".last.advance(-1).string == "b"`.
//
public fun advance : (slice : sslice, ^ count : std/core/types/int) -> sslice;
// Apply a function `f` to a specified argument `x`.
public fun apply : forall<a,b,(e :: E)> (f : (a) -> (e :: E) b, x : a) -> (e :: E) b;
private fun unsafe-assert-fail : (msg : std/core/types/string) -> ();
// clamp an `:int` to fit in a `:byte`.
public fun byte : (i : std/core/types/int) -> std/core/types/byte;
// O(`count`). Extend a string slice by `count` characters up to the end of the string.
// A negative `count` shrinks the slice up to the empty slice.
// For example:
//
// * `"abc".first.extend(1).string == "ab"`
// * `"abc".last.extend(-1).string == ""`
//
public fun extend : (slice : sslice, ^ count : std/core/types/int) -> sslice;
private fun first1 : (s : std/core/types/string) -> sslice;
// Convert a string to upper-case
public fun to-upper : (s : std/core/types/string) -> std/core/types/string;
public fun cdiv-exp10 : (i : std/core/types/int, n : std/core/types/int) -> std/core/types/int;
public fun mul-exp10 : (i : std/core/types/int, n : std/core/types/int) -> std/core/types/int;
// Return the common prefix of two strings (upto `upto` characters (default is minimum length of the two strings))
public fun common-prefix : (s : std/core/types/string, t : std/core/types/string, ^ upto : (std/core/types/optional :: V -> V)<std/core/types/int>) -> sslice;
// lifted
private fun .ctail-lift17262-concat : forall<a> (ys : (list :: V -> V)<a>, zss : (list :: V -> V)<(list :: V -> V)<a>>, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>) -> (list :: V -> V)<a>;
// lifted
private fun .lift17262-concat : forall<a> (ys : (list :: V -> V)<a>, zss : (list :: V -> V)<(list :: V -> V)<a>>) -> (list :: V -> V)<a>;
// Concatenate all lists in a list (e.g. flatten the list). (tail-recursive)
public fun concat : forall<a> (xss : (list :: V -> V)<(list :: V -> V)<a>>) -> (list :: V -> V)<a>;
// The `const` funs returns its first argument and ignores the second.
public fun const : forall<a,b> (x : a, y : b) -> a;
// Return a 'constant' function that ignores its argument and always returns the same result
public fun const.1 : forall<a,b> (default : a) -> (total :: E) ((x : b) -> a);
// If the slice is not empty,
// return the first character, and a new slice that is advanced by 1.
public fun next : (slice : sslice) -> (std/core/types/maybe :: V -> V)<(std/core/types/char, sslice)>;
// Return the number of decimal digits of `i`. Return `0` when `i==0`.
public fun count-digits : (i : std/core/types/int) -> std/core/types/int;
// Convert a `:maybe<a>` value to `:a`, using the `nothing` parameter for `Nothing`.
public fun default : forall<a> (m : (std/core/types/maybe :: V -> V)<a>, nothing : a) -> a;
// Use default value `def` in case of an error.
public fun default.1 : forall<a> (t : (error :: V -> V)<a>, def : a) -> a;
// Transform an `:error` type to an `:either` value.
public fun either : forall<a> (t : (error :: V -> V)<a>) -> (std/core/types/either :: (V, V) -> V)<exception,a>;
private fun xends-with : (s : std/core/types/string, post : std/core/types/string) -> std/core/types/bool;
// monadic lift
private fun .mlift17691-op : forall<a,b,(e :: E)> (.acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<b>>, f : (a) -> (e :: E) (list :: V -> V)<b>, zz : (list :: V -> V)<a>, ys1.17289 : (list :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// monadic lift
private fun .mlift17692-op : forall<a,b,(e :: E)> (.accm : ((list :: V -> V)<b>) -> (list :: V -> V)<b>, f : (a) -> (e :: E) (list :: V -> V)<b>, zz : (list :: V -> V)<a>, ys1.17289 : (list :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// lifted
private fun .ctail-lift17263-flatmap : forall<a,b,(e :: E)> (f : (a) -> (e :: E) (list :: V -> V)<b>, ys : (list :: V -> V)<b>, zs : (list :: V -> V)<a>, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<b>>) -> (e :: E) (list :: V -> V)<b>;
// lifted
private fun .ctailm-lift17263-flatmap : forall<a,b,(e :: E)> (f : (a) -> (e :: E) (list :: V -> V)<b>, ys : (list :: V -> V)<b>, zs : (list :: V -> V)<a>, .accm : ((list :: V -> V)<b>) -> (list :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// lifted
private fun .lift17263-flatmap : forall<a,b,(e :: E)> (f : (a) -> (e :: E) (list :: V -> V)<b>, ys : (list :: V -> V)<b>, zs : (list :: V -> V)<a>) -> (e :: E) (list :: V -> V)<b>;
// Concatenate the result lists from applying a function to all elements.
public fun flatmap : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, f : (a) -> (e :: E) (list :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// lifted
private fun .lift17264-reverse-append : forall<a> (acc : (list :: V -> V)<a>, ys : (list :: V -> V)<a>) -> (list :: V -> V)<a>;
// Efficiently reverse a list `xs` and append it to `tl`:
// `reverse-append(xs,tl) == reserve(xs) ++ tl
public fun reverse-append : forall<a> (xs : (list :: V -> V)<a>, tl : (list :: V -> V)<a>) -> (list :: V -> V)<a>;
// monadic lift
private fun .mlift17693-force : forall<a,(e :: E)> (r : (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>, x0 : a) -> <(std/core/types/st :: H -> E)<(std/core/types/global :: H)>,(std/core/types/div :: X)|(e :: E)> a;
// monadic lift
private fun .mlift17694-force : forall<a,(e :: E)> (r : (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>, .y.17405 : () -> <(std/core/types/st :: H -> E)<(std/core/types/global :: H)>,(std/core/types/div :: X)|(e :: E)> a) -> <(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>,(std/core/types/div :: X),(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/types/write :: H -> X)<(std/core/types/global :: H)>|(e :: E)> a;
// monadic lift
private fun .mlift17695-force : forall<a,(e :: E)> (r : (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>, .y.17403 : (std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>) -> <(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/types/div :: E),(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>,(std/core/types/write :: H -> X)<(std/core/types/global :: H)>|(e :: E)> a;
// Force a delayed value; the value is computed only on the first
// call to `force` and cached afterwards.
public fun force : forall<a,(e :: E)> (delayed : (delayed :: (E, V) -> V)<(e :: E),a>) -> (e :: E) a;
// Generic show: shows the internal representation of an object as a string
// Note: this breaks parametricity so it should not be public
private fun gshow : forall<a> (a) -> std/core/types/string;
// Return the host environment: `dotnet`, `browser`, `webworker`, `node`, or `libc`.
public fun host : () -> <(std/core/types/ndet :: X)> std/core/types/string;
// The `ignore` function ignores its argument.
public fun ignore : forall<a> (x : a) -> ();
// clamp an `:int` to fit in an `:int64_t`.
public fun int64 : (i : std/core/types/int) -> std/core/types/int64;
// lifted
private fun .ctail-lift17265-intersperse : forall<a> (ys : (list :: V -> V)<a>, s : a, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>) -> (list :: V -> V)<a>;
// lifted
private fun .lift17265-intersperse : forall<a> (ys : (list :: V -> V)<a>, s : a) -> (list :: V -> V)<a>;
// Insert a separator `sep`  between all elements of a list `xs` .
public fun intersperse : forall<a> (xs : (list :: V -> V)<a>, sep : a) -> (list :: V -> V)<a>;
// clamp an `:int` to fit in an `:intptr_t`. 
public fun intptr_t : (i : std/core/types/int) -> std/core/types/intptr_t;
// Is this an even integer?
public fun is-even : (i : std/core/types/int) -> std/core/types/bool;
// Return the number of ending `0` digits of `i`. Return `0` when `i==0`.
public fun is-exp10 : (i : std/core/types/int) -> std/core/types/int;
private fun last1 : (s : std/core/types/string) -> sslice;
// Used by the compiler to wrap main console applications
public fun main-console : forall<a,(e :: E)> (main : () -> (e :: E) a) -> (e :: E) a;
// monadic lift
private fun .mlift17696-op : forall<a,b,(e :: E)> (.acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<b>>, f : (value : a, rest : (list :: V -> V)<a>) -> (e :: E) b, yy : (list :: V -> V)<a>, .ctail.17321 : b) -> (e :: E) (list :: V -> V)<b>;
// monadic lift
private fun .mlift17697-op : forall<a,b,(e :: E)> (.accm : ((list :: V -> V)<b>) -> (list :: V -> V)<b>, f : (value : a, rest : (list :: V -> V)<a>) -> (e :: E) b, yy : (list :: V -> V)<a>, .ctail.17326 : b) -> (e :: E) (list :: V -> V)<b>;
// lifted
private fun .ctail-lift17266-map-peek : forall<a,b,(e :: E)> (f : (value : a, rest : (list :: V -> V)<a>) -> (e :: E) b, ys : (list :: V -> V)<a>, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<b>>) -> (e :: E) (list :: V -> V)<b>;
// lifted
private fun .ctailm-lift17266-map-peek : forall<a,b,(e :: E)> (f : (value : a, rest : (list :: V -> V)<a>) -> (e :: E) b, ys : (list :: V -> V)<a>, .accm : ((list :: V -> V)<b>) -> (list :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// lifted
private fun .lift17266-map-peek : forall<a,b,(e :: E)> (f : (value : a, rest : (list :: V -> V)<a>) -> (e :: E) b, ys : (list :: V -> V)<a>) -> (e :: E) (list :: V -> V)<b>;
// Apply a function `f`  to each element of the input list in sequence where `f` takes
// both the current element and the tail list as arguments.
public fun map-peek : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, f : (value : a, rest : (list :: V -> V)<a>) -> (e :: E) b) -> (e :: E) (list :: V -> V)<b>;
private val maxListStack : std/core/types/int;
public fun mbint : (m : (std/core/types/maybe :: V -> V)<std/core/types/int>) -> std/core/types/int;
public fun negate : (i : std/core/types/int) -> std/core/types/int;
private val trace-enabled : (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),std/core/types/bool>;
// Compose two funs `f` and `g`.
public fun o : forall<a,b,c,(e :: E)> (f : (a) -> (e :: E) b, g : (c) -> (e :: E) a) -> ((x : c) -> (e :: E) b);
// Set a `hndler` that is always called when the `action` finishes (either normally or with an exception).
public fun on-exit : forall<a,(e :: E)> (hndler : () -> (e :: E) (), action : () -> (e :: E) a) -> (e :: E) a;
// monadic lift
private fun .mlift17698-once : forall<(_h :: H),(_e :: E),a> (calc : () -> a, r : (std/core/types/ref :: (H, V) -> V)<(_h :: H),(std/core/types/maybe :: V -> V)<a>>, .y.17422 : (std/core/types/maybe :: V -> V)<a>) -> <(std/core/types/read :: H -> X)<(_h :: H)>,(std/core/types/write :: H -> X)<(_h :: H)>,(std/core/types/div :: E)|(_e :: E)> a;
// Given a total function to calculate a value `:a`, return
// a total function that only calculates the value once and then
// returns the cached result.
public fun once : forall<a> (calc : () -> a) -> (() -> a);
private fun xparse-int : (s : std/core/types/string, hex : std/core/types/bool) -> (std/core/types/maybe :: V -> V)<std/core/types/int>;
public fun phantom : forall<a> () -> a;
// Returns a singleton list.
public fun single : forall<a> (x : a) -> (list :: V -> V)<a>;
// Convert a string to lower-case
public fun to-lower : (s : std/core/types/string) -> std/core/types/string;
private fun xtrace : (message : std/core/types/string) -> ();
private fun xtrace-any : forall<a> (message : std/core/types/string, x : a) -> ();
private val unique-count : (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),std/core/types/int>;
// _Unsafe_. This function removes the non-termination effect (`:div`) from the effect of an action
public fun unsafe-nodiv : forall<a,(e :: E)> (action : () -> <(std/core/types/div :: X)|(e :: E)> a) -> (e :: E) a;
// _Unsafe_. This function removes the exception effect (`:exn`) from the effect of an action
public fun unsafe-noexn : forall<a,(e :: E)> (action : () -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a) -> (e :: E) a;
public fun unvlist : forall<a> (xs : (list :: V -> V)<a>) -> (std/core/types/vector :: V -> V)<a>;
// Create a new vector of length `n`  with initial elements given by function `f` .
private fun vector-initz : forall<a> (n : std/core/types/ssize_t, f : (std/core/types/ssize_t) -> a) -> (std/core/types/vector :: V -> V)<a>;
// Substract two character codePoints
public fun (-.4) : (c : std/core/types/char, d : std/core/types/char) -> (total :: E) std/core/types/char;
public fun int.7 : (b : std/core/types/bool) -> std/core/types/int;
public fun int.8 : (x : std/core/types/order) -> std/core/types/int;
public fun (!=.4) : (x : std/core/types/order, y : std/core/types/order) -> std/core/types/bool;
public fun (!=.5) : (x : std/core/types/bool, y : std/core/types/bool) -> std/core/types/bool;
// Add two character code points
public fun (+.4) : (c : std/core/types/char, d : std/core/types/char) -> (total :: E) std/core/types/char;
// Append two lists.
public fun .ctail-append : forall<a> (xs : (list :: V -> V)<a>, ys : (list :: V -> V)<a>, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>) -> (list :: V -> V)<a>;
// Append two lists.
public fun append : forall<a> (xs : (list :: V -> V)<a>, ys : (list :: V -> V)<a>) -> (list :: V -> V)<a>;
// Append two lists.
public fun (++) : forall<a> (xs : (list :: V -> V)<a>, ys : (list :: V -> V)<a>) -> (list :: V -> V)<a>;
// Append two strings.
public fun (++.1) : (x : std/core/types/string, y : std/core/types/string) -> std/core/types/string;
private fun printsln : (s : std/core/types/string) -> <(console :: X)> ();
public fun (==.4) : (x : std/core/types/order, y : std/core/types/order) -> std/core/types/bool;
public fun (==.5) : (x : std/core/types/bool, y : std/core/types/bool) -> std/core/types/bool;
public fun (<.5) : (x : std/core/types/order, y : std/core/types/order) -> std/core/types/bool;
public fun (<.6) : (x : std/core/types/bool, y : std/core/types/bool) -> std/core/types/bool;
public fun order : (i : std/core/types/int) -> std/core/types/order;
// Compare two strings.
// Uses the character codes directly for comparison
public fun compare.4 : (x : std/core/types/string, y : std/core/types/string) -> std/core/types/order;
public fun (<.7) : (x : std/core/types/string, y : std/core/types/string) -> std/core/types/bool;
public fun (>.3) : (x : std/core/types/order, y : std/core/types/order) -> std/core/types/bool;
public fun (>.4) : (x : std/core/types/bool, y : std/core/types/bool) -> std/core/types/bool;
public fun (>.5) : (x : std/core/types/string, y : std/core/types/string) -> std/core/types/bool;
public fun compare.1 : (x : std/core/types/char, y : std/core/types/char) -> std/core/types/order;
public fun compare.2 : (x : std/core/types/bool, y : std/core/types/bool) -> std/core/types/order;
public fun compare.3 : (x : std/core/types/double, y : std/core/types/double) -> std/core/types/order;
public fun (>=.4) : (x : std/core/types/order, y : std/core/types/order) -> std/core/types/bool;
public fun (>=.5) : (x : std/core/types/bool, y : std/core/types/bool) -> std/core/types/bool;
public fun (>=.6) : (x : std/core/types/string, y : std/core/types/string) -> std/core/types/bool;
// lifted
private fun .lift17267-joinsep : (sep : std/core/types/string, ys : (list :: V -> V)<std/core/types/string>, acc : std/core/types/string) -> std/core/types/string;
// Concatenate all strings in a list
private fun joinsep : (xs : (list :: V -> V)<std/core/types/string>, sep : std/core/types/string) -> std/core/types/string;
// lifted
private fun .lift17268-join.2 : (ys : (list :: V -> V)<std/core/types/string>, acc : std/core/types/string) -> std/core/types/string;
// Concatenate all strings in a list
public fun join.2 : (xs : (list :: V -> V)<std/core/types/string>) -> std/core/types/string;
// Concatenate all strings in a list using a specific separator
public fun join.3 : (xs : (list :: V -> V)<std/core/types/string>, sep : std/core/types/string) -> std/core/types/string;
public fun (<=.5) : (x : std/core/types/order, y : std/core/types/order) -> std/core/types/bool;
public fun (<=.6) : (x : std/core/types/bool, y : std/core/types/bool) -> std/core/types/bool;
public fun (<=.7) : (x : std/core/types/string, y : std/core/types/string) -> std/core/types/bool;
public fun inc : (i : std/core/types/int) -> std/core/types/int;
private fun decr : (i : std/core/types/int32) -> std/core/types/int32;
private fun decr.1 : (i : std/core/types/ssize_t) -> std/core/types/ssize_t;
private fun incr : (i : std/core/types/int32) -> std/core/types/int32;
private fun incr.1 : (i : std/core/types/ssize_t) -> std/core/types/ssize_t;
// monadic lift
private fun .mlift17699-op : forall<(e :: E)> (action : (std/core/types/ssize_t) -> (e :: E) (), end : std/core/types/ssize_t, i : std/core/types/ssize_t, wild_ : ()) -> (e :: E) ();
// lifted
private fun .lift17269-forz : forall<(e :: E)> (action : (std/core/types/ssize_t) -> (e :: E) (), end : std/core/types/ssize_t, i : std/core/types/ssize_t) -> (e :: E) ();
// Executes `action`  for each integer between `start`  upto `end`  (including both `start`  and `end` ).
// If `start > end`  the function returns without any call to `action` .
private fun forz : forall<(e :: E)> (start : std/core/types/ssize_t, end : std/core/types/ssize_t, action : (std/core/types/ssize_t) -> (e :: E) ()) -> (e :: E) ();
private fun foreach-indexedz : forall<a,(e :: E)> (v : (std/core/types/vector :: V -> V)<a>, f : (a, std/core/types/ssize_t) -> (e :: E) ()) -> (e :: E) ();
// lifted
private fun .lift17270-length.1 : forall<a> (ys : (list :: V -> V)<a>, acc : std/core/types/int) -> std/core/types/int;
// Returns the length of a list.
public fun length.1 : forall<a> (xs : (list :: V -> V)<a>) -> std/core/types/int;
// Return the length of a vector.
public fun length.2 : forall<a> (^ v : (std/core/types/vector :: V -> V)<a>) -> std/core/types/int;
// Returns an integer list of increasing elements from `lo`  to `hi`
// (including both `lo`  and `hi` ).
// If `lo > hi`  the function returns the empty list.
public fun .ctail-list : (lo : std/core/types/int, hi : std/core/types/int, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<std/core/types/int>>) -> (total :: E) (list :: V -> V)<std/core/types/int>;
// Returns an integer list of increasing elements from `lo`  to `hi`
// (including both `lo`  and `hi` ).
// If `lo > hi`  the function returns the empty list.
public fun list : (lo : std/core/types/int, hi : std/core/types/int) -> (total :: E) (list :: V -> V)<std/core/types/int>;
// Returns an integer list of increasing elements from `lo`  to `hi` with stride `stride`.
// If `lo > hi`  the function returns the empty list.
public fun .ctail-list.1 : (lo : std/core/types/int, hi : std/core/types/int, stride : std/core/types/int, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<std/core/types/int>>) -> (total :: E) (list :: V -> V)<std/core/types/int>;
// Returns an integer list of increasing elements from `lo`  to `hi` with stride `stride`.
// If `lo > hi`  the function returns the empty list.
public fun list.1 : (lo : std/core/types/int, hi : std/core/types/int, stride : std/core/types/int) -> (total :: E) (list :: V -> V)<std/core/types/int>;
// monadic lift
private fun .mlift17700-op : forall<a,(e :: E)> (.acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>, f : (std/core/types/int) -> (e :: E) a, hi : std/core/types/int, lo : std/core/types/int, .ctail.17333 : a) -> (e :: E) (list :: V -> V)<a>;
// monadic lift
private fun .mlift17701-op : forall<a,(e :: E)> (.accm : ((list :: V -> V)<a>) -> (list :: V -> V)<a>, f : (std/core/types/int) -> (e :: E) a, hi : std/core/types/int, lo : std/core/types/int, .ctail.17338 : a) -> (e :: E) (list :: V -> V)<a>;
// Applies a function `f` to list of increasing elements from `lo`  to `hi`
// (including both `lo`  and `hi` ).
// If `lo > hi`  the function returns the empty list.
public fun .ctail-list.2 : forall<a,(e :: E)> (lo : std/core/types/int, hi : std/core/types/int, f : (std/core/types/int) -> (e :: E) a, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>) -> (e :: E) (list :: V -> V)<a>;
// Applies a function `f` to list of increasing elements from `lo`  to `hi`
// (including both `lo`  and `hi` ).
// If `lo > hi`  the function returns the empty list.
public fun .ctailm-list.2 : forall<a,(e :: E)> (lo : std/core/types/int, hi : std/core/types/int, f : (std/core/types/int) -> (e :: E) a, .accm : ((list :: V -> V)<a>) -> (list :: V -> V)<a>) -> (e :: E) (list :: V -> V)<a>;
// Applies a function `f` to list of increasing elements from `lo`  to `hi`
// (including both `lo`  and `hi` ).
// If `lo > hi`  the function returns the empty list.
public fun list.2 : forall<a,(e :: E)> (lo : std/core/types/int, hi : std/core/types/int, f : (std/core/types/int) -> (e :: E) a) -> (e :: E) (list :: V -> V)<a>;
// monadic lift
private fun .mlift17702-op : forall<a,(e :: E)> (.acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>, f : (std/core/types/int) -> (e :: E) a, hi : std/core/types/int, lo : std/core/types/int, stride : std/core/types/int, .ctail.17339 : a) -> (e :: E) (list :: V -> V)<a>;
// monadic lift
private fun .mlift17703-op : forall<a,(e :: E)> (.accm : ((list :: V -> V)<a>) -> (list :: V -> V)<a>, f : (std/core/types/int) -> (e :: E) a, hi : std/core/types/int, lo : std/core/types/int, stride : std/core/types/int, .ctail.17344 : a) -> (e :: E) (list :: V -> V)<a>;
// Returns an integer list of increasing elements from `lo`  to `hi` with stride `stride`.
// If `lo > hi`  the function returns the empty list.
public fun .ctail-list.3 : forall<a,(e :: E)> (lo : std/core/types/int, hi : std/core/types/int, stride : std/core/types/int, f : (std/core/types/int) -> (e :: E) a, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>) -> (e :: E) (list :: V -> V)<a>;
// Returns an integer list of increasing elements from `lo`  to `hi` with stride `stride`.
// If `lo > hi`  the function returns the empty list.
public fun .ctailm-list.3 : forall<a,(e :: E)> (lo : std/core/types/int, hi : std/core/types/int, stride : std/core/types/int, f : (std/core/types/int) -> (e :: E) a, .accm : ((list :: V -> V)<a>) -> (list :: V -> V)<a>) -> (e :: E) (list :: V -> V)<a>;
// Returns an integer list of increasing elements from `lo`  to `hi` with stride `stride`.
// If `lo > hi`  the function returns the empty list.
public fun list.3 : forall<a,(e :: E)> (lo : std/core/types/int, hi : std/core/types/int, stride : std/core/types/int, f : (std/core/types/int) -> (e :: E) a) -> (e :: E) (list :: V -> V)<a>;
// monadic lift
private fun .mlift17704-op : forall<a,b,(e :: E)> (.acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<b>>, f : (a) -> (e :: E) b, xx : (list :: V -> V)<a>, .ctail.17345 : b) -> (e :: E) (list :: V -> V)<b>;
// monadic lift
private fun .mlift17705-op : forall<a,b,(e :: E)> (.accm : ((list :: V -> V)<b>) -> (list :: V -> V)<b>, f : (a) -> (e :: E) b, xx : (list :: V -> V)<a>, .ctail.17350 : b) -> (e :: E) (list :: V -> V)<b>;
// Apply a function `f`  to each element of the input list in sequence.
public fun .ctail-map.5 : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, f : (a) -> (e :: E) b, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<b>>) -> (e :: E) (list :: V -> V)<b>;
// Apply a function `f`  to each element of the input list in sequence.
public fun .ctailm-map.5 : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, f : (a) -> (e :: E) b, .accm : ((list :: V -> V)<b>) -> (list :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// Apply a function `f`  to each element of the input list in sequence.
public fun map.5 : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, f : (a) -> (e :: E) b) -> (e :: E) (list :: V -> V)<b>;
// Create a list of characters from `lo`  to `hi`  (inclusive).
public fun list.4 : (lo : std/core/types/char, hi : std/core/types/char) -> (total :: E) (list :: V -> V)<std/core/types/char>;
// Convert a `:maybe` type to a list type.
public fun list.5 : forall<a> (m : (std/core/types/maybe :: V -> V)<a>) -> (list :: V -> V)<a>;
// Convert a string to a list of characters
public fun list.6 : (s : std/core/types/string) -> (total :: E) (list :: V -> V)<std/core/types/char>;
// Convert a vector to a list.
public fun list.7 : forall<a> (v : (std/core/types/vector :: V -> V)<a>) -> (list :: V -> V)<a>;
// monadic lift
private fun .mlift17706-map : forall<a,(e :: E)> (.y.17457 : a) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
public fun map : forall<a,b,(e :: E)> (m : (std/core/types/maybe :: V -> V)<a>, f : (a) -> (e :: E) b) -> (e :: E) (std/core/types/maybe :: V -> V)<b>;
// monadic lift
private fun .mlift17707-map.1 : forall<a,b,(e :: E)> (.y.17459 : b) -> (e :: E) (std/core/types/either :: (V, V) -> V)<a,b>;
// Map over the `Right` component of an `:either` type.
public fun map.1 : forall<a,b,c,(e :: E)> (e : (std/core/types/either :: (V, V) -> V)<a,b>, f : (b) -> (e :: E) c) -> (e :: E) (std/core/types/either :: (V, V) -> V)<a,c>;
// monadic lift
private fun .mlift17708-map.2 : forall<a,(e :: E)> (.y.17461 : a, .y.17462 : a) -> (e :: E) (a, a);
// monadic lift
private fun .mlift17709-map.2 : forall<a,b,(e :: E)> (f : (a) -> (e :: E) b, t : (a, a), .y.17461 : b) -> (e :: E) (b, b);
public fun map.2 : forall<a,b,(e :: E)> (t : (a, a), f : (a) -> (e :: E) b) -> (e :: E) (b, b);
// monadic lift
private fun .mlift17710-map.3 : forall<a,(e :: E)> (.y.17463 : a, .y.17464 : a, .y.17465 : a) -> (e :: E) (a, a, a);
// monadic lift
private fun .mlift17711-map.3 : forall<a,b,(e :: E)> (.y.17463 : b, f : (a) -> (e :: E) b, t : (a, a, a), .y.17464 : b) -> (e :: E) (b, b, b);
// monadic lift
private fun .mlift17712-map.3 : forall<a,b,(e :: E)> (f : (a) -> (e :: E) b, t : (a, a, a), .y.17463 : b) -> (e :: E) (b, b, b);
public fun map.3 : forall<a,b,(e :: E)> (t : (a, a, a), f : (a) -> (e :: E) b) -> (e :: E) (b, b, b);
// monadic lift
private fun .mlift17713-map.4 : forall<a,(e :: E)> (.y.17466 : a, .y.17467 : a, .y.17468 : a, .y.17469 : a) -> (e :: E) (a, a, a, a);
// monadic lift
private fun .mlift17714-map.4 : forall<a,b,(e :: E)> (.y.17466 : b, .y.17467 : b, f : (a) -> (e :: E) b, t : (a, a, a, a), .y.17468 : b) -> (e :: E) (b, b, b, b);
// monadic lift
private fun .mlift17715-map.4 : forall<a,b,(e :: E)> (.y.17466 : b, f : (a) -> (e :: E) b, t : (a, a, a, a), .y.17467 : b) -> (e :: E) (b, b, b, b);
// monadic lift
private fun .mlift17716-map.4 : forall<a,b,(e :: E)> (f : (a) -> (e :: E) b, t : (a, a, a, a), .y.17466 : b) -> (e :: E) (b, b, b, b);
public fun map.4 : forall<a,b,(e :: E)> (t : (a, a, a, a), f : (a) -> (e :: E) b) -> (e :: E) (b, b, b, b);
// Apply a function `f` to each character in a string
public fun map.6 : forall<(e :: E)> (s : std/core/types/string, f : (std/core/types/char) -> (e :: E) std/core/types/char) -> (e :: E) std/core/types/string;
// monadic lift
private fun .mlift17717-map.7 : forall<a,(e :: E)> (i : std/core/types/ssize_t, w : (std/core/types/vector :: V -> V)<a>, .y.17471 : a) -> (e :: E) ();
// monadic lift
private fun .mlift17718-map.7 : forall<a,(e :: E)> (w : (std/core/types/vector :: V -> V)<a>, wild_ : ()) -> (e :: E) (std/core/types/vector :: V -> V)<a>;
// Apply a total function `f` to each element in a vector `v`
public fun map.7 : forall<a,b,(e :: E)> (v : (std/core/types/vector :: V -> V)<a>, f : (a) -> (e :: E) b) -> (e :: E) (std/core/types/vector :: V -> V)<b>;
// Right-align a string to width `width`  using `fill`  (default is a space) to fill from the left.
public fun pad-left : (s : std/core/types/string, ^ width : std/core/types/int, fill : (std/core/types/optional :: V -> V)<std/core/types/char>) -> std/core/types/string;
// Show an `:int` as a hexadecimal value.\
// The `width`  parameter specifies how wide the hex value is where `"0"`  is used to align.\
// The `use-capitals` parameter (= `True`) determines if captical letters should be used to display the hexadecimal digits.\
// The `pre` (=`"0x"`) is an optional prefix for the number (goes between the sign and the number).
public fun show-hex : (i : std/core/types/int, width : (std/core/types/optional :: V -> V)<std/core/types/int>, use-capitals : (std/core/types/optional :: V -> V)<std/core/types/bool>, pre : (std/core/types/optional :: V -> V)<std/core/types/string>) -> std/core/types/string;
public fun sign.1 : (d : std/core/types/double) -> std/core/types/order;
// Is the integer positive (stricly greater than zero)
public fun is-pos.2 : (i : std/core/types/int) -> std/core/types/bool;
// Is the value positive?
public fun is-pos.3 : (d : std/core/types/double) -> std/core/types/bool;
// Is the list empty?
public fun is-empty : forall<a> (xs : (list :: V -> V)<a>) -> std/core/types/bool;
// Is a slice empty?
public fun is-empty.1 : (slice : sslice) -> std/core/types/bool;
// Is a string empty?
public fun is-empty.2 : (s : std/core/types/string) -> std/core/types/bool;
public fun (||) : forall<a> (m1 : (std/core/types/maybe :: V -> V)<a>, m2 : (std/core/types/maybe :: V -> V)<a>) -> (std/core/types/maybe :: V -> V)<a>;
// Choose a non-empty string
public fun (||.1) : (x : std/core/types/string, y : std/core/types/string) -> std/core/types/string;
// Show a character as a string
private fun show-char : (c : std/core/types/char) -> std/core/types/string;
// Show a `:double` in exponential (scientific) notation.
// The optional `precision` (= `-17`) specifies the precision.
// If `>=0` it specifies the number of digits behind the dot (up to `17` max).
// If negative, then at most the absolute value of `precision` digits behind the dot are used.
public fun show-exp : (d : std/core/types/double, precision : (std/core/types/optional :: V -> V)<std/core/types/int>) -> std/core/types/string;
// Show a `:double` fixed-point notation.
// The optional `precision` (= `-2`) specifies the maximum precision.
// If `>=0` it specifies the number of digits behind the dot (up to `20` max).
// If negative, then at most the absolute value of `precision` digits behind the dot are used.
// This may still show a number in exponential notation if the it is too small or large,
// in particular, for  a `d` where `d > 1.0e21` or `d < 1.0e-15`, or if
// `precision.abs > 17`, the `show-exp` routine is used.
public fun show-fixed : (d : std/core/types/double, precision : (std/core/types/optional :: V -> V)<std/core/types/int>) -> std/core/types/string;
// lifted
private fun .lift17271-show-list : (sep : std/core/types/string, ys : (list :: V -> V)<std/core/types/string>, acc : std/core/types/string) -> std/core/types/string;
// monadic lift
private fun .mlift17719-show-list : forall<(e :: E)> (.y.17473 : (list :: V -> V)<std/core/types/string>) -> (e :: E) std/core/types/string;
// Convert a list to a string
public fun show-list : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, show-elem : (a) -> (e :: E) std/core/types/string) -> (e :: E) std/core/types/string;
// Convert an `:int` to a string
public fun show : (i : std/core/types/int) -> std/core/types/string;
// Show a `:double` as a string.
// If `d >= 1.0e-5` and `d < 1.0e+21`, `show-fixed` is used and otherwise `show-exp`.
// Default `precision` is `-17`.
public fun show.1 : (d : std/core/types/double, precision : (std/core/types/optional :: V -> V)<std/core/types/int>) -> std/core/types/string;
// Show the exception message
public fun show.10 : (exn : exception) -> std/core/types/string;
// Show a `:char` as a character literal
public fun show.2 : (c : std/core/types/char) -> std/core/types/string;
// lifted
private fun .lift17272-show.3 : (ys : (list :: V -> V)<std/core/types/string>, acc : std/core/types/string) -> std/core/types/string;
// Show a string as a string literal
public fun show.3 : (s : std/core/types/string) -> std/core/types/string;
// Convert a `:bool` to a string
public fun show.4 : (b : std/core/types/bool) -> std/core/types/string;
// Convert a unit value `()` to a string
public fun show.5 : (u : ()) -> std/core/types/string;
// Show an `:sslice` as a string literal
public fun show.6 : (s : sslice) -> std/core/types/string;
public fun show.7 : (xs : (list :: V -> V)<std/core/types/string>) -> std/core/types/string;
public fun show.8 : (xs : (list :: V -> V)<std/core/types/int>) -> std/core/types/string;
public fun show.9 : (xs : (list :: V -> V)<std/core/types/bool>) -> std/core/types/string;
// Print a string to the console, including a final newline character.
public fun println : (s : std/core/types/string) -> <(console :: X)> ();
// Print an integer to the console, including a final newline character.
public fun println.1 : (i : std/core/types/int) -> <(console :: X)> ();
// Print a double to the console, including a final newline character.
public fun println.2 : (d : std/core/types/double) -> <(console :: X)> ();
// Print a boolean to the console, including a final newline character
public fun println.3 : (b : std/core/types/bool) -> <(console :: X)> ();
// Print a character to the console, including a final newline character.
public fun println.4 : (c : std/core/types/char) -> <(console :: X)> ();
// Print a unit value to the console, including a final newline character
public fun println.5 : (u : ()) -> <(console :: X)> ();
private fun prints : (s : std/core/types/string) -> <(console :: X)> ();
// call `throw-exn` operation of the `:exn` effect
public fun throw-exn : forall<a> (exn : exception) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>> a;
public fun .default-exn : forall<(e :: E)> (action : () -> <(console :: X),(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> ()) -> <(console :: X)|(e :: E)> ();
// Get (zero-based) element `n`  of a list. Return a `:maybe` type.
public fun ([].2) : forall<a> (xs : (list :: V -> V)<a>, n : std/core/types/int) -> (std/core/types/maybe :: V -> V)<a>;
// Raise an integer `i` to the power of `exp`.
public fun (^.1) : (i : std/core/types/int, exp : std/core/types/int) -> std/core/types/int;
// O(1). Return the string slice from the end of `slice` argument
// to the end of the string.
public fun after : (slice : sslice) -> sslice;
// monadic lift
private fun .mlift17720-all : forall<a,(e :: E)> (predicate : (a) -> (e :: E) std/core/types/bool, xx : (list :: V -> V)<a>, .y.17476 : std/core/types/bool) -> (e :: E) std/core/types/bool;
// Do all elements satisfy a predicate ?
public fun all : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool) -> (e :: E) std/core/types/bool;
// monadic lift
private fun .mlift17721-any : forall<a,(e :: E)> (predicate : (a) -> (e :: E) std/core/types/bool, xx : (list :: V -> V)<a>, .y.17480 : std/core/types/bool) -> (e :: E) std/core/types/bool;
// Are there any elements in a list that satisfy a predicate ?
public fun any : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool) -> (e :: E) std/core/types/bool;
public fun assert : (message : std/core/types/string, condition : std/core/types/bool) -> ();
// Return the element at position `index` in vector `v`, or `Nothing` if out of bounds
public fun at : forall<a> (^ v : (std/core/types/vector :: V -> V)<a>, ^ index : std/core/types/int) -> (std/core/types/maybe :: V -> V)<a>;
// O(1). Return the string slice from the start of a string up to the
// start of `slice` argument.
public fun before : (slice : sslice) -> sslice;
// Convert an int to a boolean, using `False` for 0 and `True` otherwise.
public fun bool : (i : std/core/types/int) -> std/core/types/bool;
// Convert a `:maybe` type to a boolean using `False` for `Nothing` and `True` for `Just`.
public fun bool.1 : forall<a> (m : (std/core/types/maybe :: V -> V)<a>) -> std/core/types/bool;
// Convert a string to a boolean, using `False` for the empty string and `True` otherwise.
public fun bool.2 : (s : std/core/types/string) -> std/core/types/bool;
// O(`n`). The first `n` (default = `1`) characters in a string.
public fun first : (s : std/core/types/string, n : (std/core/types/optional :: V -> V)<std/core/types/int>) -> sslice;
// Convert the first character of a string to uppercase.
public fun capitalize : (s : std/core/types/string) -> std/core/types/string;
// Catch any exception raised in `action` and handle it.
// Use `on-exn` or `on-exit` when appropiate.
public fun try : forall<a,(e :: E)> (action : () -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a, hndl : (exception) -> (e :: E) a) -> (e :: E) a;
// monadic lift
private fun .mlift17722-try.1 : forall<a,(e :: E)> (.y.17485 : a) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> (error :: V -> V)<a>;
// Transform an exception effect to an  `:error` type.
public fun try.1 : forall<a,(e :: E)> (action : () -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a) -> (e :: E) (error :: V -> V)<a>;
// _Deprecated_; use `try` instead. Catch an exception raised by `throw` and handle it.
// Use `on-exn` or `on-exit` when appropiate.
public fun catch : forall<a,(e :: E)> (action : () -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a, hndl : (exception) -> (e :: E) a) -> (e :: E) a;
public fun cdivmod-exp10 : (i : std/core/types/int, n : std/core/types/int) -> (std/core/types/int, std/core/types/int);
// Concatenate a list of `:maybe` values
public fun .ctail-concat-maybe : forall<a> (xs : (list :: V -> V)<(std/core/types/maybe :: V -> V)<a>>, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>) -> (list :: V -> V)<a>;
// Concatenate a list of `:maybe` values
public fun concat-maybe : forall<a> (xs : (list :: V -> V)<(std/core/types/maybe :: V -> V)<a>>) -> (list :: V -> V)<a>;
// monadic lift
private fun .mlift17723-op : forall<a,(e :: E)> (action : (std/core/types/ssize_t) -> (e :: E) (std/core/types/maybe :: V -> V)<a>, end : std/core/types/ssize_t, i : std/core/types/ssize_t, .y.17488 : (std/core/types/maybe :: V -> V)<a>) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
// lifted
private fun .lift17273-for-whilez : forall<a,(e :: E)> (action : (std/core/types/ssize_t) -> (e :: E) (std/core/types/maybe :: V -> V)<a>, end : std/core/types/ssize_t, i : std/core/types/ssize_t) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
// Executes `action`  for each integer between `start`  upto `end`  (including both `start`  and `end` ).
// If `start > end`  the function returns without any call to `action` .
// If `action` returns `Just`, the iteration is stopped and the result returned
private fun for-whilez : forall<a,(e :: E)> (start : std/core/types/ssize_t, end : std/core/types/ssize_t, action : (std/core/types/ssize_t) -> (e :: E) (std/core/types/maybe :: V -> V)<a>) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
// O(1). The entire string as a slice
public fun slice : (s : std/core/types/string) -> sslice;
// monadic lift
private fun .mlift17724-foreach-while : forall<a,b,(e :: E)> (action : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, xx : (list :: V -> V)<a>, .y.17493 : (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/maybe :: V -> V)<b>;
// Invoke `action` for each element of a list while `action` return `Nothing`
public fun foreach-while : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, action : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/maybe :: V -> V)<b>;
// monadic lift
private fun .mlift17725-foreach-while.1 : forall<a,(e :: E)> (action : (c : std/core/types/char) -> (e :: E) (std/core/types/maybe :: V -> V)<a>, rest : sslice, .y.17497 : (std/core/types/maybe :: V -> V)<a>) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
// Apply a function for each character in a string slice.
// If `action` returns `Just`, the function returns immediately with that result.
public fun foreach-while.1 : forall<a,(e :: E)> (slice : sslice, action : (c : std/core/types/char) -> (e :: E) (std/core/types/maybe :: V -> V)<a>) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
// Invoke a function for each character in a string.
// If `action` returns `Just`, the function returns immediately with that result.
public fun foreach-while.2 : forall<a,(e :: E)> (s : std/core/types/string, action : (c : std/core/types/char) -> (e :: E) (std/core/types/maybe :: V -> V)<a>) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
// Invoke a function `f` for each element in a vector `v`.
// If `f` returns `Just`, the iteration is stopped early and the result is returned.
public fun foreach-while.3 : forall<a,b,(e :: E)> (v : (std/core/types/vector :: V -> V)<a>, f : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/maybe :: V -> V)<b>;
// monadic lift
private fun .mlift17726-foreach : forall<a,(e :: E)> (action : (a) -> (e :: E) (), xx : (list :: V -> V)<a>, wild_ : ()) -> (e :: E) ();
// Invoke `action` for each element of a list
public fun foreach : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, action : (a) -> (e :: E) ()) -> (e :: E) ();
// monadic lift
private fun .mlift17727-foreach.1 : forall<_a,(e :: E)> (wild_ : ()) -> (e :: E) (std/core/types/maybe :: V -> V)<_a>;
// monadic lift
private fun .mlift17728-foreach.1 : forall<_a,(e :: E)> (wild_0 : (std/core/types/maybe :: V -> V)<_a>) -> (e :: E) ();
// Apply a function for each character in a string slice.
public fun foreach.1 : forall<(e :: E)> (slice : sslice, action : (c : std/core/types/char) -> (e :: E) ()) -> (e :: E) ();
// monadic lift
private fun .mlift17729-foreach.2 : forall<_a,(e :: E)> (wild_ : ()) -> (e :: E) (std/core/types/maybe :: V -> V)<_a>;
// monadic lift
private fun .mlift17730-foreach.2 : forall<_a,(e :: E)> (wild_0 : (std/core/types/maybe :: V -> V)<_a>) -> (e :: E) ();
// Invoke a function for each character in a string
public fun foreach.2 : forall<(e :: E)> (s : std/core/types/string, action : (c : std/core/types/char) -> (e :: E) ()) -> (e :: E) ();
// Invoke a function `f` for each element in a vector `v`
public fun foreach.3 : forall<a,(e :: E)> (v : (std/core/types/vector :: V -> V)<a>, f : (a) -> (e :: E) ()) -> (e :: E) ();
// O(n). Return the number of characters in a string.
public fun count.1 : (s : std/core/types/string) -> std/core/types/int;
// O(n). Return the number of characters in a string slice
public fun count.2 : (slice : sslice) -> std/core/types/int;
// Count the number of times a predicate is true for each character in a string
public fun count.3 : (s : std/core/types/string, pred : (std/core/types/char) -> std/core/types/bool) -> std/core/types/int;
public fun dec : (i : std/core/types/int) -> std/core/types/int;
// Create a new `:delayed` value.
public fun delay : forall<a,(e :: E)> (action : () -> (e :: E) a) -> (delayed :: (E, V) -> V)<(e :: E),a>;
// Calculate `10^exp`
public fun exp10 : (exp : std/core/types/int) -> std/core/types/int;
// Is the integer negative (stricly smaller than zero)
public fun is-neg.2 : (i : std/core/types/int) -> std/core/types/bool;
// Is the value negative?
public fun is-neg.3 : (d : std/core/types/double) -> std/core/types/bool;
public fun divmod-exp10 : (i : std/core/types/int, n : std/core/types/int) -> (std/core/types/int, std/core/types/int);
// Drop the first `n` elements of a list (or fewer if the list is shorter than `n`)
public fun drop : forall<a> (xs : (list :: V -> V)<a>, n : std/core/types/int) -> (list :: V -> V)<a>;
// monadic lift
private fun .mlift17731-drop-while : forall<a,(e :: E)> (predicate : (a) -> (e :: E) std/core/types/bool, xs : (list :: V -> V)<a>, xx : (list :: V -> V)<a>, .y.17513 : std/core/types/bool) -> (e :: E) (list :: V -> V)<a>;
// Drop all initial elements that satisfy `predicate`
public fun drop-while : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool) -> (e :: E) (list :: V -> V)<a>;
// An empty slice
public val empty : sslice;
// Does string `s`  end with `post`?
// If so, returns a slice of `s` from the start up to the `post` string at the end.
public fun ends-with : (s : std/core/types/string, post : std/core/types/string) -> (std/core/types/maybe :: V -> V)<sslice>;
// Throw an exception with a specified message.
public fun throw : forall<a> (message : std/core/types/string, info : (std/core/types/optional :: V -> V)<exception-info>) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>> a;
// Transform an `:error` type back to an `exn` effect.
public fun throw.1 : forall<a> (err : (error :: V -> V)<a>) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>> a;
// monadic lift
private fun .mlift17732-error-pattern : forall<a> (definition : std/core/types/string, location : std/core/types/string, .c.17520 : std/core/types/string) -> a;
// Raise a pattern match exception. This is function is used internally by the
// compiler to generate error messages on pattern match failures.
public fun error-pattern : forall<a> (location : std/core/types/string, definition : std/core/types/string) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>> a;
// Transform an `:error` type back to an `exn` effect.
public fun exn : forall<a> (err : (error :: V -> V)<a>) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>> a;
// Calculate `2^exp`.
public fun exp2 : (exp : std/core/types/int) -> std/core/types/int;
// monadic lift
private fun .mlift17733-op : forall<a,(e :: E)> (.acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>, pred : (a) -> (e :: E) std/core/types/bool, x : a, xx : (list :: V -> V)<a>, .y.17523 : std/core/types/bool) -> (e :: E) (list :: V -> V)<a>;
// monadic lift
private fun .mlift17734-op : forall<a,(e :: E)> (.accm : ((list :: V -> V)<a>) -> (list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool, x : a, xx : (list :: V -> V)<a>, .y.17528 : std/core/types/bool) -> (e :: E) (list :: V -> V)<a>;
// Retain only those elements of a list that satisfy the given predicate `pred`.
// For example: `filter([1,2,3],odd?) == [1,3]`
public fun .ctail-filter : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>) -> (e :: E) (list :: V -> V)<a>;
// Retain only those elements of a list that satisfy the given predicate `pred`.
// For example: `filter([1,2,3],odd?) == [1,3]`
public fun .ctailm-filter : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool, .accm : ((list :: V -> V)<a>) -> (list :: V -> V)<a>) -> (e :: E) (list :: V -> V)<a>;
// Retain only those elements of a list that satisfy the given predicate `pred`.
// For example: `filter([1,2,3],odd?) == [1,3]`
public fun filter : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool) -> (e :: E) (list :: V -> V)<a>;
// monadic lift
private fun .mlift17735-op : forall<a,b,(e :: E)> (.acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<b>>, pred : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, xx : (list :: V -> V)<a>, .y.17536 : (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// monadic lift
private fun .mlift17736-op : forall<a,b,(e :: E)> (.accm : ((list :: V -> V)<b>) -> (list :: V -> V)<b>, pred : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, xx : (list :: V -> V)<a>, .y.17541 : (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// Retain only those elements of a list that satisfy the given predicate `pred`.
// For example: `filterMap([1,2,3],fn(i) { if (i.odd?) then Nothing else Just(i*i) }) == [4]`
public fun .ctail-filter-map : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, pred : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<b>>) -> (e :: E) (list :: V -> V)<b>;
// Retain only those elements of a list that satisfy the given predicate `pred`.
// For example: `filterMap([1,2,3],fn(i) { if (i.odd?) then Nothing else Just(i*i) }) == [4]`
public fun .ctailm-filter-map : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, pred : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, .accm : ((list :: V -> V)<b>) -> (list :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// Retain only those elements of a list that satisfy the given predicate `pred`.
// For example: `filterMap([1,2,3],fn(i) { if (i.odd?) then Nothing else Just(i*i) }) == [4]`
public fun filter-map : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, pred : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
private fun is-zero.1 : (i : std/core/types/ssize_t) -> std/core/types/bool;
// Is the value zero?
public fun is-zero.2 : (d : std/core/types/double) -> std/core/types/bool;
// Find the first element satisfying some predicate
public fun find : forall<a> (xs : (list :: V -> V)<a>, pred : (a) -> std/core/types/bool) -> (std/core/types/maybe :: V -> V)<a>;
// O(n). If it occurs, return the position of substring `sub` in `s`, tupled with
// the position just following the substring `sub`.
public fun find.1 : (s : std/core/types/string, sub : std/core/types/string) -> (std/core/types/maybe :: V -> V)<sslice>;
// Return the last index of substring `sub` in `s` if it occurs.
public fun find-last : (s : std/core/types/string, sub : std/core/types/string) -> (std/core/types/maybe :: V -> V)<sslice>;
// Find the first element satisfying some predicate and return it.
public fun find-maybe : forall<a,b> (xs : (list :: V -> V)<a>, pred : (a) -> (std/core/types/maybe :: V -> V)<b>) -> (std/core/types/maybe :: V -> V)<b>;
// monadic lift
private fun .mlift17737-op : forall<a,b,(e :: E)> (.acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<b>>, f : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, xx : (list :: V -> V)<a>, .y.17549 : (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// monadic lift
private fun .mlift17738-op : forall<a,b,(e :: E)> (.accm : ((list :: V -> V)<b>) -> (list :: V -> V)<b>, f : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, xx : (list :: V -> V)<a>, .y.17554 : (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// Concatenate the `Just` result elements from applying a function to all elements.
public fun .ctail-flatmap-maybe : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, f : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<b>>) -> (e :: E) (list :: V -> V)<b>;
// Concatenate the `Just` result elements from applying a function to all elements.
public fun .ctailm-flatmap-maybe : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, f : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, .accm : ((list :: V -> V)<b>) -> (list :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// Concatenate the `Just` result elements from applying a function to all elements.
public fun flatmap-maybe : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, f : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// monadic lift
private fun .mlift17739-fold-int : forall<a,(e :: E)> (end : std/core/types/int, f : (std/core/types/int, a) -> (e :: E) a, start0 : std/core/types/int, x : a) -> (e :: E) a;
// fold over the integers between [`start`,`end`] (inclusive).
public fun fold-int : forall<a,(e :: E)> (start : std/core/types/int, end : std/core/types/int, init : a, f : (std/core/types/int, a) -> (e :: E) a) -> (e :: E) a;
// fold over the integers between [0,`upto`)  (not including `upto`).
public fun fold-int.1 : forall<a,(e :: E)> (upto : std/core/types/int, init : a, f : (std/core/types/int, a) -> (e :: E) a) -> (e :: E) a;
// monadic lift
private fun .mlift17740-foldl : forall<a,(e :: E),b> (f : (a, b) -> (e :: E) a, xx : (list :: V -> V)<b>, .y.17566 : a) -> (e :: E) a;
// Fold a list from the left, i.e. `foldl([1,2],0,(+)) == (0+1)+2`
// Since `foldl` is tail recursive, it is preferred over `foldr` when using an associative function `f`
public fun foldl : forall<a,b,(e :: E)> ((list :: V -> V)<a>, b, (b, a) -> (e :: E) b) -> (e :: E) b;
public fun foldl1 : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, f : (a, a) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a;
// lifted
private fun .lift17274-reverse : forall<a> (acc : (list :: V -> V)<a>, ys : (list :: V -> V)<a>) -> (list :: V -> V)<a>;
// Reverse a list.
public fun reverse : forall<a> (xs : (list :: V -> V)<a>) -> (list :: V -> V)<a>;
// Fold a list from the right, i.e. `foldr([1,2],0,(+)) == 1+(2+0)`
// Note, `foldr` is less efficient than `foldl` as it reverses the list first.
public fun foldr : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, z : b, f : (a, b) -> (e :: E) b) -> (e :: E) b;
public fun foldr1 : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, f : (a, a) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a;
// monadic lift
private fun .mlift17741-op : forall<(e :: E)> (action : (std/core/types/int) -> (e :: E) (), end : std/core/types/int, i : std/core/types/int, wild_ : ()) -> (e :: E) ();
// lifted
private fun .lift17275-for : forall<(e :: E)> (action : (std/core/types/int) -> (e :: E) (), end : std/core/types/int, i : std/core/types/int) -> (e :: E) ();
// Executes `action`  for each integer between `start`  upto `end`  (including both `start`  and `end` ).
// If `start > end`  the function returns without any call to `action` .
public fun for : forall<(e :: E)> (^ start : std/core/types/int, end : std/core/types/int, action : (std/core/types/int) -> (e :: E) ()) -> (e :: E) ();
// monadic lift
private fun .mlift17742-op : forall<a,(e :: E)> (action : (std/core/types/int) -> (e :: E) (std/core/types/maybe :: V -> V)<a>, end : std/core/types/int, i : std/core/types/int, .y.17581 : (std/core/types/maybe :: V -> V)<a>) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
// lifted
private fun .lift17276-for-while : forall<a,(e :: E)> (action : (std/core/types/int) -> (e :: E) (std/core/types/maybe :: V -> V)<a>, end : std/core/types/int, i : std/core/types/int) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
// Executes `action`  for each integer between `start`  upto `end`  (including both `start`  and `end` ).
// If `start > end`  the function returns without any call to `action` .
// If `action` returns `Just`, the iteration is stopped and the result returned
public fun for-while : forall<a,(e :: E)> (start : std/core/types/int, end : std/core/types/int, action : (std/core/types/int) -> (e :: E) (std/core/types/maybe :: V -> V)<a>) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
// monadic lift
private fun .mlift17743-foreach-indexed : forall<(h :: H),(e :: E)> (i : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>, .y.17589 : std/core/types/int) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> ();
// monadic lift
private fun .mlift17744-foreach-indexed : forall<(h :: H),(e :: E)> (i : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>, wild_ : ()) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> ();
// monadic lift
private fun .mlift17745-foreach-indexed : forall<(h :: H),a,(e :: E)> (action : (std/core/types/int, a) -> (e :: E) (), i : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>, x : a, j : std/core/types/int) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> ();
// Invoke `action` for each element of a list, passing also the position of the element.
public fun foreach-indexed : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, action : (std/core/types/int, a) -> (e :: E) ()) -> (e :: E) ();
// Invoke a function `f` for each element in a vector `v`
public fun foreach-indexed.1 : forall<a,(e :: E)> (v : (std/core/types/vector :: V -> V)<a>, f : (a, std/core/types/int) -> (e :: E) ()) -> (e :: E) ();
// Print a string to the console.
public fun print : (s : std/core/types/string) -> <(console :: X)> ();
// Print an integer to the console.
public fun print.1 : (i : std/core/types/int) -> <(console :: X)> ();
// Print a double to the console.
public fun print.2 : (d : std/core/types/double) -> <(console :: X)> ();
// Print a boolean to the console
public fun print.3 : (b : std/core/types/bool) -> <(console :: X)> ();
// Print a character to the console.
public fun print.4 : (c : std/core/types/char) -> <(console :: X)> ();
// Print a unit value to the console
public fun print.5 : (u : ()) -> <(console :: X)> ();
// Generic print routine: prints the internal representation as a string to the console,
// including a final newline character.
// Note: this breaks parametricity so it should not be public
private fun gprint : forall<a> (x : a) -> <(console :: X)> ();
// Generic print routine: prints the internal representation as a string to the console, including a final newline character.
// Note: this breaks parametricity so it should not be public
private fun gprintln : forall<a> (x : a) -> <(console :: X)> ();
// Return the head of list if the list is not empty.
public fun head.1 : forall<a> (xs : (list :: V -> V)<a>) -> (std/core/types/maybe :: V -> V)<a>;
// Return the head of list if the list is not empty, or use `default` otherwise
public fun head.2 : forall<a> (xs : (list :: V -> V)<a>, default : a) -> a;
// Return the first character of a string as a string (or the empty string)
public fun head.3 : (s : std/core/types/string) -> std/core/types/string;
// Return the first character of a string (or `Nothing` for the empty string).
public fun head-char : (s : std/core/types/string) -> (std/core/types/maybe :: V -> V)<std/core/types/char>;
private fun index-of-acc : forall<a> (xs : (list :: V -> V)<a>, pred : (a) -> std/core/types/bool, idx : std/core/types/int) -> std/core/types/int;
// Returns the index of the first element where `pred` holds, or `-1` if no such element exists.
public fun index-of : forall<a> (xs : (list :: V -> V)<a>, pred : (a) -> std/core/types/bool) -> std/core/types/int;
// Return the list without its last element.
// Return an empty list for an empty list.
public fun .ctail-init : forall<a> (xs : (list :: V -> V)<a>, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>) -> (list :: V -> V)<a>;
// Return the list without its last element.
// Return an empty list for an empty list.
public fun init : forall<a> (xs : (list :: V -> V)<a>) -> (list :: V -> V)<a>;
// An invalid slice
public val invalid : sslice;
// Is the character a lower-case ASCII character ?
public fun is-lower : (c : std/core/types/char) -> std/core/types/bool;
// Is the character an upper-case ASCII character ?
public fun is-upper : (c : std/core/types/char) -> std/core/types/bool;
// Is the character an ASCII letter is-
public fun is-alpha : (c : std/core/types/char) -> std/core/types/bool;
// Is the character an ASCII digit ?
public fun is-digit : (c : std/core/types/char) -> std/core/types/bool;
// Is the character ASCII letter or digit?
public fun is-alpha-num : (c : std/core/types/char) -> std/core/types/bool;
// Is the character an ASCII character, e.g. `c <= '\x7F'`  ?
public fun is-ascii : (c : std/core/types/char) -> std/core/types/bool;
// Is the character an ASCII control character, e.g. `c < ' '`  ?
public fun is-control : (c : std/core/types/char) -> std/core/types/bool;
// Is the character an ASCII hexa-decimal digit ?
public fun is-hex-digit : (c : std/core/types/char) -> std/core/types/bool;
// Is a slice not empty?
public fun is-notempty : (slice : sslice) -> std/core/types/bool;
// Is a string not empty?
public fun is-notempty.1 : (s : std/core/types/string) -> std/core/types/bool;
// Is a slice invalid?
public fun is-valid : (slice : sslice) -> std/core/types/bool;
// Tests if a character is an element of `" \t\n\r"`
public fun is-white : (c : std/core/types/char) -> std/core/types/bool;
// Append `end` to each string in the list `xs` and join them all together.\
// `join-end([],end) === ""`\
// `join-end(["a","b"],"/") === "a/b/"`
public fun join-end : (xs : (list :: V -> V)<std/core/types/string>, end : std/core/types/string) -> std/core/types/string;
// Return the last element of a list (or `Nothing` for the empty list)
public fun last : forall<a> (xs : (list :: V -> V)<a>) -> (std/core/types/maybe :: V -> V)<a>;
// Return the last element of a list (or `default` for the empty list)
public fun last.1 : forall<a> (xs : (list :: V -> V)<a>, default : a) -> a;
// O(`n`). The last `n` (default = `1`) characters in a string
public fun last.2 : (s : std/core/types/string, n : (std/core/types/optional :: V -> V)<std/core/types/int>) -> sslice;
// Take the first `n` elements of a list (or fewer if the list is shorter than `n`)
public fun .ctail-take : forall<a> (xs : (list :: V -> V)<a>, n : std/core/types/int, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>) -> (list :: V -> V)<a>;
// Take the first `n` elements of a list (or fewer if the list is shorter than `n`)
public fun take : forall<a> (xs : (list :: V -> V)<a>, n : std/core/types/int) -> (list :: V -> V)<a>;
// split a list at position `n`
public fun split : forall<a> (xs : (list :: V -> V)<a>, n : std/core/types/int) -> ((list :: V -> V)<a>, (list :: V -> V)<a>);
// Split a string into parts that were delimited by `sep`. The delimeters are not included in the results.
// For example: `split("1,,2",",") == ["1","","2]`
public fun split.1 : (s : std/core/types/string, sep : std/core/types/string) -> (list :: V -> V)<std/core/types/string>;
// Split a string into at most `n` parts that were delimited by a string `sep`. The delimeters are not included in the results (except for possibly the final part).
// For example: `split("1,2,3",",",2) == ["1","2,3"]`
public fun split.2 : (s : std/core/types/string, sep : std/core/types/string, ^ n : std/core/types/int) -> (list :: V -> V)<std/core/types/string>;
// Split a string into a list of lines
public fun lines : (s : std/core/types/string) -> (list :: V -> V)<std/core/types/string>;
// Lookup the first element satisfying some predicate
public fun lookup : forall<a,b> (xs : (list :: V -> V)<(a, b)>, pred : (a) -> std/core/types/bool) -> (std/core/types/maybe :: V -> V)<b>;
// monadic lift
private fun .mlift17746-op : forall<a,(e :: E)> (.y.17596 : a, .y.17597 : (list :: V -> V)<a>) -> (e :: E) (list :: V -> V)<a>;
// monadic lift
private fun .mlift17747-op : forall<a,b,(e :: E)> (f : (idx : std/core/types/int, value : a) -> (e :: E) b, i : std/core/types/int, yy : (list :: V -> V)<a>, .y.17596 : b) -> (e :: E) (list :: V -> V)<b>;
// lifted
private fun .lift17277-map-indexed : forall<a,b,(e :: E)> (f : (idx : std/core/types/int, value : a) -> (e :: E) b, ys : (list :: V -> V)<a>, i : std/core/types/int) -> (e :: E) (list :: V -> V)<b>;
// Apply a function `f`  to each element of the input list in sequence where takes
// both the index of the current element and the element itself as arguments.
public fun map-indexed : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, f : (idx : std/core/types/int, value : a) -> (e :: E) b) -> (e :: E) (list :: V -> V)<b>;
// monadic lift
private fun .mlift17748-op : forall<a,(e :: E)> (.y.17600 : a, .y.17601 : (list :: V -> V)<a>) -> (e :: E) (list :: V -> V)<a>;
// monadic lift
private fun .mlift17749-op : forall<a,b,(e :: E)> (f : (idx : std/core/types/int, value : a, rest : (list :: V -> V)<a>) -> (e :: E) b, i : std/core/types/int, yy : (list :: V -> V)<a>, .y.17600 : b) -> (e :: E) (list :: V -> V)<b>;
// lifted
private fun .lift17278-map-indexed-peek : forall<a,b,(e :: E)> (f : (idx : std/core/types/int, value : a, rest : (list :: V -> V)<a>) -> (e :: E) b, ys : (list :: V -> V)<a>, i : std/core/types/int) -> (e :: E) (list :: V -> V)<b>;
// Apply a function `f`  to each element of the input list in sequence where takes
// both the index of the current element, the element itself, and the tail list as arguments.
public fun map-indexed-peek : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, f : (idx : std/core/types/int, value : a, rest : (list :: V -> V)<a>) -> (e :: E) b) -> (e :: E) (list :: V -> V)<b>;
// monadic lift
private fun .mlift17750-op : forall<a,b,(e :: E)> (.acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<b>>, action : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, xx : (list :: V -> V)<a>, .y.17604 : (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// monadic lift
private fun .mlift17751-op : forall<a,b,(e :: E)> (.accm : ((list :: V -> V)<b>) -> (list :: V -> V)<b>, action : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, xx : (list :: V -> V)<a>, .y.17608 : (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// Invoke `action` on each element of a list while `action` returns `Just`
public fun .ctail-map-while : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, action : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<b>>) -> (e :: E) (list :: V -> V)<b>;
// Invoke `action` on each element of a list while `action` returns `Just`
public fun .ctailm-map-while : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, action : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, .accm : ((list :: V -> V)<b>) -> (list :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// Invoke `action` on each element of a list while `action` returns `Just`
public fun map-while : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, action : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// Return the maximum of two integers
public fun max : (i : std/core/types/int, j : std/core/types/int) -> std/core/types/int;
// Returns the largest of two doubles
public fun max.1 : (x : std/core/types/double, y : std/core/types/double) -> std/core/types/double;
// Returns the largest element of a list of integers (or `default` (=`0`) for the empty list)
public fun maximum : (xs : (list :: V -> V)<std/core/types/int>, default : (std/core/types/optional :: V -> V)<std/core/types/int>) -> std/core/types/int;
// Returns the largest element of a list of doubles (or `0` for the empty list)
public fun maximum.1 : (xs : (list :: V -> V)<std/core/types/double>) -> std/core/types/double;
// Match a `:maybe` value and either return a default value on `Nothing` or apply a function to the value on `Just`
public fun maybe : forall<a,b,(e :: E)> (m : (std/core/types/maybe :: V -> V)<a>, onNothing : b, onJust : (a) -> (e :: E) b) -> (e :: E) b;
// Convert a `:maybe<a>` value to `:a`, using the `nothing` parameter for `Nothing`.
// This is an alias for `default`.
public fun maybe.1 : forall<a> (m : (std/core/types/maybe :: V -> V)<a>, nothing : a) -> a;
// Convert a `:either` to a `:maybe` type discarding the value of the `Left` constructor
// and using `Just` for the `Right` constructor.
public fun maybe.2 : forall<a,b> (e : (std/core/types/either :: (V, V) -> V)<a,b>) -> (std/core/types/maybe :: V -> V)<b>;
// Convert a list to a `:maybe` type, using `Nothing` for an empty list, and otherwise `Just` on the head element.
// Note: this is just `head`.
public fun maybe.3 : forall<a> (xs : (list :: V -> V)<a>) -> (std/core/types/maybe :: V -> V)<a>;
// Transform a boolean to a maybe type, using `Nothing` for `False`
public fun maybe.4 : (b : std/core/types/bool) -> (std/core/types/maybe :: V -> V)<()>;
// Transform an integer to a maybe type, using `Nothing` for `0`
public fun maybe.5 : (i : std/core/types/int) -> (std/core/types/maybe :: V -> V)<std/core/types/int>;
// Transform a string to a maybe type, using `Nothing` for an empty string
public fun maybe.6 : (s : std/core/types/string) -> (std/core/types/maybe :: V -> V)<std/core/types/string>;
// Transform an `:error` type to a `:maybe` value.
public fun maybe.7 : forall<a> (t : (error :: V -> V)<a>) -> (std/core/types/maybe :: V -> V)<a>;
// Transform a `:null` type to a `:maybe` type. Note that it is not
// always the case that `id(x) == maybe(null(x))` (e.g. when `x = Just(Nothing)`).
public fun maybe.8 : forall<a> (n : (null :: V -> V)<a>) -> (std/core/types/maybe :: V -> V)<a>;
// Return the minimum of two integers
public fun min : (i : std/core/types/int, j : std/core/types/int) -> std/core/types/int;
// Returns the smallest of two doubles
public fun min.1 : (x : std/core/types/double, y : std/core/types/double) -> std/core/types/double;
// Returns the smallest element of a list of integers (or `default` (=`0`) for the empty list)
public fun minimum : (xs : (list :: V -> V)<std/core/types/int>, default : (std/core/types/optional :: V -> V)<std/core/types/int>) -> std/core/types/int;
// Returns the smallest element of a list of doubles (or `0` for the empty list)
public fun minimum.1 : (xs : (list :: V -> V)<std/core/types/double>) -> std/core/types/double;
// Disable tracing completely.
public fun notrace : () -> <(std/core/types/st :: H -> E)<(std/core/types/global :: H)>> ();
// Transform a `:maybe` type to a `:null` type (using `null` for `Nothing`).
public fun null : forall<a> (x : (std/core/types/maybe :: V -> V)<a>) -> (null :: V -> V)<a>;
// Cast a integer that is zero to a null
public fun null.1 : (i : std/core/types/int) -> (null :: V -> V)<std/core/types/int>;
// Cast an empty string a null
public fun null.2 : (s : std/core/types/string) -> (null :: V -> V)<std/core/types/string>;
// Cast a boolean `False` to null
public fun null.3 : (b : std/core/types/bool) -> (null :: V -> V)<()>;
// Left-align a string to width `width`  using `fill`  (default is a space) to fill on the right.
public fun pad-right : (s : std/core/types/string, ^ width : std/core/types/int, fill : (std/core/types/optional :: V -> V)<std/core/types/char>) -> std/core/types/string;
// Is `pre`  a prefix of `s`? If so, returns a slice
// of `s` following `pre` up to the end of `s`.
public fun starts-with : (s : std/core/types/string, pre : std/core/types/string) -> (std/core/types/maybe :: V -> V)<sslice>;
// Trim off a substring `sub` while `s` starts with that string.
public fun trim-left.1 : (s : std/core/types/string, sub : std/core/types/string) -> std/core/types/string;
// Trim off a substring `sub` while `s` ends with that string.
public fun trim-right.1 : (s : std/core/types/string, sub : std/core/types/string) -> std/core/types/string;
// Trim whitespace on the left and right side of a string
public fun trim : (s : std/core/types/string) -> std/core/types/string;
// Parse an integer after trimming whitespace.
// If an illegal digit character is encountered `Nothing` is returned.
// An empty string will result in `Just(0)`.
// A string can start with a `-` sign for negative numbers,
// and with `0x` or `0X` for hexadecimal numbers (in which case the `hex` parameter is ignored).
public fun parse-int : (s : std/core/types/string, hex : (std/core/types/optional :: V -> V)<std/core/types/bool>) -> (std/core/types/maybe :: V -> V)<std/core/types/int>;
// Parse an integer using `parseInt`. If an illegal digit character is encountered the
// `default` value is returned. An empty string will also result in `default`.
public fun parse-int-default : (s : std/core/types/string, default : (std/core/types/optional :: V -> V)<std/core/types/int>, hex : (std/core/types/optional :: V -> V)<std/core/types/bool>) -> std/core/types/int;
// monadic lift
private fun .mlift17752-partition-acc : forall<a,(e :: E)> (acc1 : (list :: V -> V)<a>, acc2 : (list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool, x : a, xx : (list :: V -> V)<a>, .y.17617 : std/core/types/bool) -> (e :: E) ((list :: V -> V)<a>, (list :: V -> V)<a>);
private fun partition-acc : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool, acc1 : (list :: V -> V)<a>, acc2 : (list :: V -> V)<a>) -> (e :: E) ((list :: V -> V)<a>, (list :: V -> V)<a>);
// Partition a list in two lists where the first list contains
// those elements that satisfy the given predicate `pred`.
// For example: `partition([1,2,3],odd?) == ([1,3],[2])`
public fun partition : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool) -> (e :: E) ((list :: V -> V)<a>, (list :: V -> V)<a>);
// redirect `print` and `println` calls to a specified function.
public fun print-redirect : (print : (msg : std/core/types/string) -> <(console :: X)> ()) -> <(io :: E)> ();
// Remove those elements of a list that satisfy the given predicate `pred`.
// For example: `remove([1,2,3],odd?) == [2]`
public fun remove : forall<a> (xs : (list :: V -> V)<a>, pred : (a) -> std/core/types/bool) -> (list :: V -> V)<a>;
// Repeat a string `n` times
public fun repeat : (s : std/core/types/string, ^ n : std/core/types/int) -> std/core/types/string;
// The `repeat` fun executes `action`  `n`  times.
public fun repeat.1 : forall<(e :: E)> (^ n : std/core/types/int, action : () -> (e :: E) ()) -> (e :: E) ();
// Create a list of `n`  repeated elementes `x`
public fun .ctail-replicate : forall<a> (x : a, n : std/core/types/int, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>) -> (list :: V -> V)<a>;
// Create a list of `n`  repeated elementes `x`
public fun replicate : forall<a> (x : a, n : std/core/types/int) -> (list :: V -> V)<a>;
// lifted
private fun .lift17279-reverse-join : forall<a> (acc : (list :: V -> V)<a>, ys : (list :: V -> V)<a>) -> (list :: V -> V)<a>;
// lifted
private fun .lift17280-reverse-join : (ys0 : (list :: V -> V)<std/core/types/string>, acc0 : std/core/types/string) -> std/core/types/string;
// Concatenate all strings in a list in reverse order
public fun reverse-join : (xs : (list :: V -> V)<std/core/types/string>) -> std/core/types/string;
public fun show-tuple : forall<a,b> (x : (a, b), showfst : (a) -> std/core/types/string, showsnd : (b) -> std/core/types/string) -> std/core/types/string;
// monadic lift
private fun .mlift17753-op : forall<a,(e :: E)> (acc : (list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool, y : a, ys : (list :: V -> V)<a>, yy : (list :: V -> V)<a>, .y.17625 : std/core/types/bool) -> (e :: E) ((list :: V -> V)<a>, (list :: V -> V)<a>);
// lifted
// todo: implement TRMC with multiple results to avoid the reverse
private fun .lift17281-span : forall<a,(e :: E)> (predicate : (a) -> (e :: E) std/core/types/bool, ys : (list :: V -> V)<a>, acc : (list :: V -> V)<a>) -> (e :: E) ((list :: V -> V)<a>, (list :: V -> V)<a>);
public fun span : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool) -> (e :: E) ((list :: V -> V)<a>, (list :: V -> V)<a>);
// Return the sum of a list of integers
public fun sum : (xs : (list :: V -> V)<std/core/types/int>) -> std/core/types/int;
// Return the tail of list. Returns the empty list if `xs` is empty.
public fun tail.1 : forall<a> (xs : (list :: V -> V)<a>) -> (list :: V -> V)<a>;
// Return the tail of a string (or the empty string)
public fun tail.2 : (s : std/core/types/string) -> std/core/types/string;
// monadic lift
private fun .mlift17754-op : forall<a,(e :: E)> (.acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>, predicate : (a) -> (e :: E) std/core/types/bool, x : a, xx : (list :: V -> V)<a>, .y.17630 : std/core/types/bool) -> (e :: E) (list :: V -> V)<a>;
// monadic lift
private fun .mlift17755-op : forall<a,(e :: E)> (.accm : ((list :: V -> V)<a>) -> (list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool, x : a, xx : (list :: V -> V)<a>, .y.17634 : std/core/types/bool) -> (e :: E) (list :: V -> V)<a>;
// Keep only those initial elements that satisfy `predicate`
public fun .ctail-take-while : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>) -> (e :: E) (list :: V -> V)<a>;
// Keep only those initial elements that satisfy `predicate`
public fun .ctailm-take-while : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool, .accm : ((list :: V -> V)<a>) -> (list :: V -> V)<a>) -> (e :: E) (list :: V -> V)<a>;
// Keep only those initial elements that satisfy `predicate`
public fun take-while : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool) -> (e :: E) (list :: V -> V)<a>;
// monadic lift
private fun .mlift17756-trace : forall<(_e :: E)> (message0 : std/core/types/string, .y.17641 : std/core/types/bool) -> <(std/core/types/read :: H -> X)<(std/core/types/global :: H)>|(_e :: E)> ();
// Trace a message used for debug purposes.
// The behaviour is system dependent. On a browser and node it uses
// `console.log`  by default.
// Disabled if `notrace` is called.
public fun trace : (message : std/core/types/string) -> ();
// monadic lift
private fun .mlift17757-trace-any : forall<(_e :: E),a> (message0 : std/core/types/string, x : a, .y.17643 : std/core/types/bool) -> <(std/core/types/read :: H -> X)<(std/core/types/global :: H)>|(_e :: E)> ();
public fun trace-any : forall<a> (message : std/core/types/string, x : a) -> ();
// Truncate a string to `count` characters.
public fun truncate : (s : std/core/types/string, count : std/core/types/int) -> std/core/types/string;
// Return a default value when an exception is raised
public fun try-default : forall<a,(e :: E)> (value : a, action : () -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a) -> (e :: E) a;
// monadic lift
private fun .mlift17758-unique : forall<(_e :: E)> (u : std/core/types/int) -> <(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/types/write :: H -> X)<(std/core/types/global :: H)>|(_e :: E)> std/core/types/int;
// Returns a unique integer (modulo 32-bits).
public fun unique : () -> <(std/core/types/ndet :: X)> std/core/types/int;
// Get the value of the `Just` constructor or raise an exception
public fun unjust : forall<a> (m : (std/core/types/maybe :: V -> V)<a>) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>> a;
// lifted
private fun .lift17282-unlines : (ys : (list :: V -> V)<std/core/types/string>, acc : std/core/types/string) -> std/core/types/string;
// Join a list of strings with newlines
public fun unlines : (xs : (list :: V -> V)<std/core/types/string>) -> std/core/types/string;
// lifted
private fun .lift17284-unzip : forall<a> (acc : (list :: V -> V)<a>, ys0 : (list :: V -> V)<a>) -> (list :: V -> V)<a>;
// lifted
private fun .lift17285-unzip : forall<a> (acc0 : (list :: V -> V)<a>, ys1 : (list :: V -> V)<a>) -> (list :: V -> V)<a>;
// lifted
// todo: implement TRMC for multiple results
private fun .lift17283-unzip : forall<a,b> (ys : (list :: V -> V)<(a, b)>, acc1 : (list :: V -> V)<a>, acc2 : (list :: V -> V)<b>) -> ((list :: V -> V)<a>, (list :: V -> V)<b>);
// Unzip a list of pairs into two lists
public fun unzip : forall<a,b> (xs : (list :: V -> V)<(a, b)>) -> ((list :: V -> V)<a>, (list :: V -> V)<b>);
// Convert a string to a vector of characters.
public fun vector.1 : (s : std/core/types/string) -> (std/core/types/vector :: V -> V)<std/core/types/char>;
// Create a new vector of length `n`  with initial elements `default` .
public fun vector.2 : forall<a> (^ n : std/core/types/int, default : a) -> (std/core/types/vector :: V -> V)<a>;
// Convert a list to a vector.
public fun vector.3 : forall<a> (xs : (list :: V -> V)<a>) -> (std/core/types/vector :: V -> V)<a>;
// Create a new vector of length `n`  with initial elements given by function `f` .
public fun vector-init : forall<a> (^ n : std/core/types/int, f : (std/core/types/int) -> a) -> (std/core/types/vector :: V -> V)<a>;
// monadic lift
private fun .mlift17759-while : forall<(e :: E)> (action : () -> <(std/core/types/div :: X)|(e :: E)> (), predicate : () -> <(std/core/types/div :: X)|(e :: E)> std/core/types/bool, wild_ : ()) -> <(std/core/types/div :: X)|(e :: E)> ();
// monadic lift
private fun .mlift17760-while : forall<(e :: E)> (action : () -> <(std/core/types/div :: X)|(e :: E)> (), predicate : () -> <(std/core/types/div :: X)|(e :: E)> std/core/types/bool, .y.17649 : std/core/types/bool) -> <(std/core/types/div :: X)|(e :: E)> ();
// The `while` fun executes `action`  as long as `pred`  is `true`.
public fun while : forall<(e :: E)> (predicate : () -> <(std/core/types/div :: X)|(e :: E)> std/core/types/bool, action : () -> <(std/core/types/div :: X)|(e :: E)> ()) -> <(std/core/types/div :: E)|(e :: E)> ();
// Zip two lists together by pairing the corresponding elements.
// The returned list is only as long as the smallest input list.
public fun .ctail-zip : forall<a,b> (xs : (list :: V -> V)<a>, ys : (list :: V -> V)<b>, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<(a, b)>>) -> (list :: V -> V)<(a, b)>;
// Zip two lists together by pairing the corresponding elements.
// The returned list is only as long as the smallest input list.
public fun zip : forall<a,b> (xs : (list :: V -> V)<a>, ys : (list :: V -> V)<b>) -> (list :: V -> V)<(a, b)>;
// monadic lift
private fun .mlift17761-op : forall<a,b,c,(e :: E)> (.acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<c>>, f : (a, b) -> (e :: E) c, xx : (list :: V -> V)<a>, yy : (list :: V -> V)<b>, .ctail.17381 : c) -> (e :: E) (list :: V -> V)<c>;
// monadic lift
private fun .mlift17762-op : forall<a,b,c,(e :: E)> (.accm : ((list :: V -> V)<c>) -> (list :: V -> V)<c>, f : (a, b) -> (e :: E) c, xx : (list :: V -> V)<a>, yy : (list :: V -> V)<b>, .ctail.17386 : c) -> (e :: E) (list :: V -> V)<c>;
// Zip two lists together by apply a function `f` to all corresponding elements.
// The returned list is only as long as the smallest input list.
public fun .ctail-zipwith : forall<a,b,c,(e :: E)> (xs : (list :: V -> V)<a>, ys : (list :: V -> V)<b>, f : (a, b) -> (e :: E) c, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<c>>) -> (e :: E) (list :: V -> V)<c>;
// Zip two lists together by apply a function `f` to all corresponding elements.
// The returned list is only as long as the smallest input list.
public fun .ctailm-zipwith : forall<a,b,c,(e :: E)> (xs : (list :: V -> V)<a>, ys : (list :: V -> V)<b>, f : (a, b) -> (e :: E) c, .accm : ((list :: V -> V)<c>) -> (list :: V -> V)<c>) -> (e :: E) (list :: V -> V)<c>;
// Zip two lists together by apply a function `f` to all corresponding elements.
// The returned list is only as long as the smallest input list.
public fun zipwith : forall<a,b,c,(e :: E)> (xs : (list :: V -> V)<a>, ys : (list :: V -> V)<b>, f : (a, b) -> (e :: E) c) -> (e :: E) (list :: V -> V)<c>;
// monadic lift
private fun .mlift17763-zipwith-acc : forall<(e :: E),a,b,c> (acc : (list :: V -> V)<b>, f : (std/core/types/int, a, c) -> (e :: E) b, i : std/core/types/int, xx : (list :: V -> V)<a>, yy : (list :: V -> V)<c>, .y.17664 : b) -> (e :: E) (list :: V -> V)<b>;
private fun zipwith-acc : forall<a,b,c,(e :: E)> ((std/core/types/int, a, b) -> (e :: E) c, std/core/types/int, (list :: V -> V)<c>, (list :: V -> V)<a>, (list :: V -> V)<b>) -> (e :: E) (list :: V -> V)<c>;
// monadic lift
private fun .mlift17764-op : forall<a,(e :: E)> (.y.17668 : a, .y.17669 : (list :: V -> V)<a>) -> (e :: E) (list :: V -> V)<a>;
// monadic lift
private fun .mlift17765-op : forall<a,b,c,(e :: E)> (f : (std/core/types/int, a, b) -> (e :: E) c, i : std/core/types/int, xx : (list :: V -> V)<a>, yy : (list :: V -> V)<b>, .y.17668 : c) -> (e :: E) (list :: V -> V)<c>;
// lifted
private fun .lift17286-zipwith-indexed : forall<a,b,c,(e :: E)> (f : (std/core/types/int, a, b) -> (e :: E) c, i : std/core/types/int, xs : (list :: V -> V)<a>, ys : (list :: V -> V)<b>) -> (e :: E) (list :: V -> V)<c>;
// Zip two lists together by apply a function `f` to all corresponding elements
// and their index in the list.
// The returned list is only as long as the smallest input list.
public fun zipwith-indexed : forall<a,b,c,(e :: E)> (xs0 : (list :: V -> V)<a>, ys0 : (list :: V -> V)<b>, f : (std/core/types/int, a, b) -> (e :: E) c) -> (e :: E) (list :: V -> V)<c>;
 
//------------------------------
//#kki: external declarations
 
// Add the state effect to a function effect.
public extern inject-st : forall<a,(h :: H),(e :: E)> (() -> (e :: E) a) -> (total :: E) (() -> <(std/core/types/st :: H -> E)<(h :: H)>|(e :: E)> a) = inline "#1";
public extern (==) : (std/core/types/char, std/core/types/char) -> std/core/types/bool {
  inline "(#1 == #2)";
  js inline "(#1 === #2)";
};
public extern (!=) : (std/core/types/char, std/core/types/char) -> std/core/types/bool {
  inline "(#1 != #2)";
  js inline "(#1 !== #2)";
};
public extern (<=) : (std/core/types/char, std/core/types/char) -> std/core/types/bool = inline "(#1 <= #2)";
public extern (>=) : (std/core/types/char, std/core/types/char) -> std/core/types/bool = inline "(#1 >= #2)";
public extern (<) : (std/core/types/char, std/core/types/char) -> std/core/types/bool = inline "(#1 < #2)";
public extern (>) : (std/core/types/char, std/core/types/char) -> std/core/types/bool = inline "(#1 > #2)";
// Convert a character to its unicode code point
public extern int : (std/core/types/char) -> std/core/types/int {
  inline "#1";
  c inline "kk_integer_from_int(#1,kk_context())";
  cs inline "new BigInteger(#1)";
};
// Convert a unicode code point to a character
public extern char : (^ i : std/core/types/int) -> std/core/types/char {
  inline "(#1)";
  c inline "kk_integer_clamp32_borrow(#1)";
  cs inline "Primitive.IntToInt32(#1)";
};
// Compare two integers
public extern compare : (^ x : std/core/types/int, ^ y : std/core/types/int) -> std/core/types/order {
  c inline "kk_int_as_order(kk_integer_cmp_borrow(#1,#2,kk_context()),kk_context())";
  cs inline "Primitive.IntCompare(#1,#2)";
  js inline "$std_core._int_compare(#1,#2)";
};
// Are two integers equal?
public extern (==.1) : (^ x : std/core/types/int, ^ y : std/core/types/int) -> std/core/types/bool {
  c inline "kk_integer_eq_borrow(#1,#2,kk_context())";
  cs inline "(#1 == #2)";
  js inline "$std_core._int_eq(#1,#2)";
};
// Are two integers not equal?
public extern (!=.1) : (^ x : std/core/types/int, ^ y : std/core/types/int) -> std/core/types/bool {
  c inline "kk_integer_neq_borrow(#1,#2,kk_context())";
  cs inline "(#1 != #2)";
  js inline "$std_core._int_ne(#1,#2)";
};
// Is the first integer smaller or equal to the second?
public extern (<=.1) : (^ x : std/core/types/int, ^ y : std/core/types/int) -> std/core/types/bool {
  c inline "kk_integer_lte_borrow(#1,#2,kk_context())";
  cs inline "(#1 <= #2)";
  js inline "$std_core._int_le(#1,#2)";
};
// Is the first integer greater or equal to the second?
public extern (>=.1) : (^ x : std/core/types/int, ^ y : std/core/types/int) -> std/core/types/bool {
  c inline "kk_integer_gte_borrow(#1,#2,kk_context())";
  cs inline "(#1 >= #2)";
  js inline "$std_core._int_ge(#1,#2)";
};
// Is the first integer smaller than the second?
public extern (<.1) : (^ x : std/core/types/int, ^ y : std/core/types/int) -> std/core/types/bool {
  c inline "kk_integer_lt_borrow(#1,#2,kk_context())";
  cs inline "(#1 < #2)";
  js inline "$std_core._int_lt(#1,#2)";
};
// Is the first integer greater than the second?
public extern (>.1) : (^ x : std/core/types/int, ^ y : std/core/types/int) -> std/core/types/bool {
  c inline "kk_integer_gt_borrow(#1,#2,kk_context())";
  cs inline "(#1 > #2)";
  js inline "$std_core._int_gt(#1,#2)";
};
// Add two integers.
public extern (+) : (std/core/types/int, std/core/types/int) -> std/core/types/int {
  c inline "kk_integer_add(#1,#2,kk_context())";
  cs inline "(#1 + #2)";
  js inline "$std_core._int_add(#1,#2)";
};
// Substract two integers.
public extern (-) : (std/core/types/int, std/core/types/int) -> std/core/types/int {
  c inline "kk_integer_sub(#1,#2,kk_context())";
  cs inline "(#1 - #2)";
  js inline "$std_core._int_sub(#1,#2)";
};
// Multiply two integers.
public extern (*) : (std/core/types/int, std/core/types/int) -> std/core/types/int {
  c inline "kk_integer_mul(#1,#2,kk_context())";
  cs inline "(#1 * #2)";
  js inline "$std_core._int_mul(#1,#2)";
};
// Euclidean-0 division of two integers. See also `divmod:(x : int, y : int) -> (int,int)`.
public extern (/) : (x : std/core/types/int, y : std/core/types/int) -> std/core/types/int {
  c inline "kk_integer_div(#1,#2,kk_context())";
  cs inline "Primitive.IntDiv(#1,#2)";
  js inline "$std_core._int_div(#1,#2)";
};
// Euclidean modulus of two integers; always a non-negative number. See also `divmod:(x : int, y : int) -> (int,int)`.
public extern (%) : (std/core/types/int, std/core/types/int) -> std/core/types/int {
  c inline "kk_integer_mod(#1,#2,kk_context())";
  cs inline "Primitive.IntMod(#1,#2)";
  js inline "$std_core._int_mod(#1,#2)";
};
// Euclidean-0 division & modulus.
// Euclidean division is defined as: For any `D`  and `d`  where `d!=0` , we have:
//
// 1. `D == d*(D/d) + (D%d)`
// 2. `D%d`  is always positive where `0 <= D%d < abs(d)`
//
// Moreover, Euclidean-0 is a total function, for the case where `d==0`  we have
// that `D%0 == D`  and `D/0 == 0` . So property (1) still holds, but not property (2).
//
// Useful laws that hold for Euclidean-0 division:
//
// * `D/(-d) == -(D/d)`
// * `D%(-d) == D%d`
// * `D/(2^n) == sar(D,n)         `  (with `0 <= n <= 31`  and `2^n`  means `2`  to the power of `n` )
// * `D%(2^n) == D & ((2^n) - 1)  `  (with `0 <= n <= 31`  and `2^n`  means `2`  to the power of `n` )
//
// See also _Division and modulus for computer scientists, Daan Leijen, 2001_ for further information
// available at: <http://research.microsoft.com/pubs/151917/divmodnote.pdf> .
public extern divmod : (x : std/core/types/int, y : std/core/types/int) -> (std/core/types/int, std/core/types/int) {
  c inline "kk_integer_div_mod_tuple(#1,#2,kk_context())";
  cs inline "Primitive.IntDivMod(#1,#2)";
  js inline "$std_core._int_divmod(#1,#2)";
};
// Negate an integer.
public extern (~) : (i : std/core/types/int) -> std/core/types/int {
  c inline "kk_integer_neg(#1,kk_context())";
  cs inline "(-#1)";
  js inline "$std_core._int_negate(#1)";
};
// Convert an integer to a `:double`. May return `nan` if the integer is too large to represent as a `:double`.
public extern double : (^ i : std/core/types/int) -> std/core/types/double {
  c inline "kk_integer_as_double_borrow(#1)";
  cs inline "Primitive.IntToDouble(#1)";
  js inline "$std_core._int_to_double(#1)";
};
// Is this an odd integer?
public extern is-odd : (std/core/types/int) -> std/core/types/bool {
  c inline "kk_integer_is_odd(#1,kk_context())";
  cs inline "!(#1.IsEven)";
  js inline "$std_core._int_isodd(#1)";
};
// Is this equal to zero?
public extern is-zero : (^ x : std/core/types/int) -> std/core/types/bool {
  c inline "kk_integer_is_zero_borrow(#1)";
  cs inline "(#1.IsZero)";
  js inline "$std_core._int_iszero(#1)";
};
// Return the absolute value of an integer.
public extern abs : (i : std/core/types/int) -> std/core/types/int {
  c inline "kk_integer_abs(#1,kk_context())";
  cs inline "BigInteger.Abs(#1)";
  js inline "$std_core._int_abs(#1)";
};
public extern sign : (^ i : std/core/types/int) -> std/core/types/order {
  c inline "kk_int_as_order(kk_integer_signum_borrow(#1),kk_context())";
  cs inline "Primitive.IntSign(#1)";
  js inline "$std_core._int_sign(#1)";
};
// Convert an `:int32` to an `:int`.
public extern int.1 : (i : std/core/types/int32) -> std/core/types/int {
  c inline "kk_integer_from_int(#1,kk_context())";
  cs inline "(new BigInteger(#1))";
  js inline "$std_core._int_from_int32(#1)";
};
// Minimal set of operations that we need in `std/core`.
private extern (<=.2) : (std/core/types/int32, std/core/types/int32) -> std/core/types/bool {
  inline "(#1 <= #2)";
  js inline "(#1 <= #2)";
};
private extern (<.2) : (std/core/types/int32, std/core/types/int32) -> std/core/types/bool {
  inline "(#1 < #2)";
  js inline "(#1 < #2)";
};
private extern (+.1) : (std/core/types/int32, std/core/types/int32) -> std/core/types/int32 {
  inline "(#1 + #2)";
  js inline "((#1 + #2)|0)";
};
private extern (-.1) : (std/core/types/int32, std/core/types/int32) -> std/core/types/int32 {
  inline "(#1 - #2)";
  js inline "((#1 - #2)|0)";
};
private extern is-pos : (i : std/core/types/int32) -> std/core/types/bool = inline "(#1>0)";
private extern is-neg : (i : std/core/types/int32) -> std/core/types/bool = inline "(#1<0)";
// Convert an `:ssize_t` to an `:int`.
public extern int.2 : (i : std/core/types/ssize_t) -> std/core/types/int {
  c inline "kk_integer_from_ssize_t(#1,kk_context())";
  cs inline "(new BigInteger(#1))";
  js inline "$std_core._int_from_int32(#1)";
};
// Minimal set of operations that we need in `std/core`.
private extern (<=.3) : (std/core/types/ssize_t, std/core/types/ssize_t) -> std/core/types/bool = inline "(#1 <= #2)";
private extern (>=.2) : (std/core/types/ssize_t, std/core/types/ssize_t) -> std/core/types/bool = inline "(#1 >= #2)";
private extern (<.3) : (std/core/types/ssize_t, std/core/types/ssize_t) -> std/core/types/bool = inline "(#1 < #2)";
private extern (+.2) : (std/core/types/ssize_t, std/core/types/ssize_t) -> std/core/types/ssize_t {
  inline "(#1 + #2)";
  js inline "((#1 + #2)|0)";
};
private extern (-.2) : (std/core/types/ssize_t, std/core/types/ssize_t) -> std/core/types/ssize_t {
  inline "(#1 - #2)";
  js inline "((#1 - #2)|0)";
};
private extern is-pos.1 : (i : std/core/types/ssize_t) -> std/core/types/bool = inline "(#1 > 0)";
private extern is-neg.1 : (i : std/core/types/ssize_t) -> std/core/types/bool = inline "(#1 < 0)";
// Convert an `:int64_t` to an `:int`.
public extern int.3 : (i : std/core/types/int64) -> std/core/types/int {
  c inline "kk_integer_from_int64(#1,kk_context())";
  cs inline "(new BigInteger(#1))";
  js inline "$std_core._int_from_int64(#1)";
};
// Convert an `:intptr_t` to an `:int`.
public extern int.4 : (i : std/core/types/intptr_t) -> std/core/types/int {
  c inline "kk_integer_from_intptr_t(#1,kk_context())";
  cs inline "(new BigInteger(#1))";
  js inline "$std_core._int_from_int64(#1)";
};
// Convert an `:byte` to an `:int`.
public extern int.5 : (i : std/core/types/byte) -> std/core/types/int {
  c inline "kk_integer_from_byte(#1,kk_context())";
  cs inline "(new BigInteger(#1))";
  js inline "$std_core._int_from_int32(#1)";
};
public extern (==.2) : (std/core/types/double, std/core/types/double) -> std/core/types/bool {
  inline "(#1 == #2)";
  js inline "(#1 === #2)";
};
public extern (!=.2) : (std/core/types/double, std/core/types/double) -> std/core/types/bool {
  inline "(#1 != #2)";
  js inline "(#1 !== #2)";
};
public extern (<=.4) : (std/core/types/double, std/core/types/double) -> std/core/types/bool = inline "(#1 <= #2)";
public extern (>=.3) : (std/core/types/double, std/core/types/double) -> std/core/types/bool = inline "(#1 >= #2)";
public extern (<.4) : (std/core/types/double, std/core/types/double) -> std/core/types/bool = inline "(#1 < #2)";
public extern (>.2) : (std/core/types/double, std/core/types/double) -> std/core/types/bool = inline "(#1 > #2)";
public extern (+.3) : (std/core/types/double, std/core/types/double) -> std/core/types/double = inline "(#1 + #2)";
public extern (-.3) : (std/core/types/double, std/core/types/double) -> std/core/types/double = inline "(#1 - #2)";
public extern (*.1) : (std/core/types/double, std/core/types/double) -> std/core/types/double = inline "(#1 * #2)";
public extern (/.1) : (std/core/types/double, std/core/types/double) -> std/core/types/double = inline "(#1 / #2)";
public extern (%.1) : (std/core/types/double, std/core/types/double) -> std/core/types/double {
  c inline "fmod(#1,#2)";
  inline "(#1 % #2)";
};
// Negate a `:double`.
public extern (~.1) : (d : std/core/types/double) -> std/core/types/double = inline "(-#1)";
// convert a `:double` to an `:int` using `round` to round to its nearest integer.
// (rounding to an even number on a tie)
// Returns `0` if the argument is not `finite?`.
public extern int.6 : (d : std/core/types/double) -> std/core/types/int {
  c inline "kk_integer_from_double(#1,kk_context())";
  cs inline "Primitive.IntDouble(#1)";
  js inline "$std_core._int_double(#1)";
};
// Returns the value `d`  raised to the power `p` .
public extern (^) : (d : std/core/types/double, p : std/core/types/double) -> std/core/types/double {
  c inline "pow(#1,#2)";
  cs inline "Math.Pow(#1,#2)";
  js inline "Math.pow(#1,#2)";
};
// Return the absolute value of a `:double` `d`
public extern abs.1 : (d : std/core/types/double) -> std/core/types/double {
  c inline "kk_double_abs(#1)";
  cs inline "Math.Abs(#1)";
  js inline "Math.abs(#1)";
};
// Are two strings equal?
// Uses exact equality between character codes.
public extern (==.3) : (std/core/types/string, std/core/types/string) -> std/core/types/bool {
  c inline "kk_string_is_eq(#1,#2,kk_context())";
  cs inline "(#1 == #2)";
  js inline "(#1 === #2)";
};
// Are two strings not equal?
public extern (!=.3) : (std/core/types/string, std/core/types/string) -> std/core/types/bool {
  c inline "kk_string_is_neq(#1,#2,kk_context())";
  inline "(#1 != #2)";
  js inline "(#1 !== #2)";
};
// Length returns the length in the platform specific encoding (and should not be exported)
private extern length : (s : std/core/types/string) -> std/core/types/ssize_t {
  c inline "kk_string_len(#1,kk_context())";
  cs inline "#1.Length";
  js inline "#1.length";
};
// Does string `s`  contain the string `sub`  ?
private extern xindex-of : (s : std/core/types/string, sub : std/core/types/string) -> std/core/types/ssize_t {
  c inline "kk_string_index_of1(#1,#2,kk_context())";
  cs inline "((#1).IndexOf(#2) + 1)";
  js inline "((#1).indexOf(#2) + 1)";
};
// Does string `s`  contain the string `sub`  ?
private extern xlast-index-of : (s : std/core/types/string, sub : std/core/types/string) -> std/core/types/ssize_t {
  c inline "kk_string_last_index_of1(#1,#2,kk_context())";
  cs inline "(#1.LastIndexOf(#2) + 1)";
  js inline "((#1).lastIndexOf(#2) + 1)";
};
private extern xstarts-with : (s : std/core/types/string, pre : std/core/types/string) -> std/core/types/bool {
  c inline "kk_string_starts_with(#1,#2,kk_context())";
  cs inline "#1.StartsWith(#2)";
  js inline "(#1.substr(0,#2.length) === #2)";
};
// Does string `s`  contain the string `sub`  ?
public extern contains : (s : std/core/types/string, sub : std/core/types/string) -> std/core/types/bool {
  c inline "kk_string_contains(#1,#2,kk_context())";
  cs inline "((#1).Contains(#2))";
  js inline "((#1).indexOf(#2) >= 0)";
};
// Concatenate a vector of strings
public extern join : (v : (std/core/types/vector :: V -> V)<std/core/types/string>) -> std/core/types/string {
  c inline "kk_string_join(#1,kk_context())";
  cs inline "String.Concat(#1)";
  js inline "((#1).join(\x27\x27))";
};
// Concatenate a vector of strings with a separator `sep`
public extern join.1 : (v : (std/core/types/vector :: V -> V)<std/core/types/string>, sep : std/core/types/string) -> (total :: E) std/core/types/string {
  c inline "kk_string_join_with(#1,#2,kk_context())";
  cs inline "Primitive.Concat(#1,#2)";
  js inline "((#1).join(#2))";
};
private extern splitv : (s : std/core/types/string, sep : std/core/types/string) -> (std/core/types/vector :: V -> V)<std/core/types/string> {
  c inline "kk_string_splitv(#1,#2,kk_context())";
  cs inline "(#1.Split(new String[]{#2}, StringSplitOptions.None))";
  js inline "((#1).split(#2))";
};
private extern splitv.1 : (s : std/core/types/string, sep : std/core/types/string, n : std/core/types/ssize_t) -> (std/core/types/vector :: V -> V)<std/core/types/string> {
  c inline "kk_string_splitv_atmost(#1,#2,#3,kk_context())";
  cs inline "#1.Split(new String[]{#2},#3, StringSplitOptions.None)";
  js inline "(#1).split(#2, #3)";
};
// Replace every occurrence of `pattern` to `repl` in a string.
public extern replace-all : (s : std/core/types/string, pattern : std/core/types/string, repl : std/core/types/string) -> std/core/types/string {
  c inline "kk_string_replace_all(#1,#2,#3,kk_context())";
  cs inline "(#1).Replace(#2,#3)";
  js inline "(#1).replace(new RegExp((#2).replace(/[\x5C\x5C\x5C$\x5C^*+\x5C-{}?().]/g,\x27\x5C\x5C$&\x27),\x27g\x27),#3)";
};
// Count occurences of `pattern` in a string.
public extern count : (s : std/core/types/string, pattern : std/core/types/string) -> std/core/types/int {
  c inline "kk_string_count_pattern(#1,#2,kk_context())";
  cs inline "Primitive.Count(#1,#2)";
  js inline "((#2) ? ((#1).match(new RegExp((#2).replace(/[\x5C\x5C\x5C$\x5C^*+\x5C-{}?().]/g,\x27\x5C\x5C$&\x27),\x27g\x27))||[]).length : 0)";
};
// Trim the starting white space of a string
public extern trim-left : (s : std/core/types/string) -> std/core/types/string {
  c inline "kk_string_trim_left(#1,kk_context())";
  cs inline "(#1).TrimStart()";
  js inline "((#1).replace(/^\x5Cs\x5Cs*/,\x27\x27))";
};
// Trim the ending white space of a string.
public extern trim-right : (s : std/core/types/string) -> std/core/types/string {
  c inline "kk_string_trim_right(#1,kk_context())";
  cs inline "(#1).TrimEnd()";
  js inline "((#1).replace(/\x5Cs+$/,\x27\x27))";
};
// Return the element at position `index`  in vector `v`  without bounds check!
private extern unsafe-idx : forall<a> (^ v : (std/core/types/vector :: V -> V)<a>, index : std/core/types/ssize_t) -> (total :: E) a {
  c inline "kk_vector_at_borrow(#1, #2)";
  cs inline "(#1)[#2]";
  js inline "(#1)[#2]";
};
private extern unsafe-assign : forall<a> (v : (std/core/types/vector :: V -> V)<a>, i : std/core/types/ssize_t, x : a) -> (total :: E) () {
  c inline "kk_vector_unsafe_assign(#1,#2,#3,kk_context())";
  cs inline "(#1)[#2] = #3";
  js inline "(#1)[#2] = #3";
};
private extern unsafe-vector : forall<a> (n : std/core/types/ssize_t) -> (total :: E) (std/core/types/vector :: V -> V)<a> {
  c inline "kk_vector_alloc_uninit(#1,NULL,kk_context())";
  cs inline "(new ##1[#1])";
  js inline "Array(#1)";
};
// Return the element at position `index`  in vector `v` . Raise an out of bounds exception if `index < 0`  or `index >= v.length` .
public extern ([]) : forall<a> (^ v : (std/core/types/vector :: V -> V)<a>, ^ index : std/core/types/int) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>> a {
  c inline "kk_vector_at_int_borrow(#1, #2)";
  cs inline "(#1)[Primitive.IntToInt32(#2)]";
  js inline "$std_core._vector_at(#1,#2)";
};
private extern lengthz : forall<a> (^ v : (std/core/types/vector :: V -> V)<a>) -> std/core/types/ssize_t {
  c inline "kk_vector_len_borrow(#1)";
  cs inline "((#1).Length)";
  js inline "((#1).length)";
};
// Create an empty vector.
public extern vector : forall<a> () -> (std/core/types/vector :: V -> V)<a> {
  c inline "kk_vector_empty()";
  cs inline "new ##1[0]";
  js inline "[]";
};
// _Unsafe_. This function removes the non-termination effect (`:div`) from the effect of an action
public extern unsafe-nostate : forall<a,(h :: H)> (action : () -> <(std/core/types/st :: H -> E)<(h :: H)>,(console :: X)> a) -> (() -> <(console :: X)> a) = inline "#1";
public extern inject-local : forall<a,(e :: E),(h :: H)> (action : () -> (e :: E) a) -> (total :: E) (() -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> a) = inline "#1";
// Assign to an entry in a local `:vector` variable.
public extern ([].1) : forall<a,(e :: E),(h :: H)> (^ self : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/core/types/vector :: V -> V)<a>>, ^ index : std/core/types/int, assigned : a) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> () {
  c inline "kk_ref_vector_assign_borrow(#1,#2,#3,kk_context())";
  cs inline "(#1)[(int)#2] = #3";
  js inline "(#1)[#2] = #3";
};
// .open is used in the compiler to open up closed effects.
// Usually simplified away but still present if --no-simplify flag is given
public extern .open : forall<a,b> (x : a) -> (total :: E) b = inline "#1";
// Magic casting to the `:any` type.
public extern .toany : forall<a> (x : a) -> std/core/types/any {
  inline "#1";
  cs inline "(object)(#1)";
};
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
inline fun is-exnError // inline size: 1
  = fn(exception-info: exception-info){
    match (exception-info) {
      ((std/core/ExnError() : exception-info ) as .pat: exception-info)
         -> std/core/types/True;
      (.pat0: exception-info)
         -> std/core/types/False;
    };
  };
inline fun is-exnAssert // inline size: 1
  = fn(exception-info: exception-info){
    match (exception-info) {
      ((std/core/ExnAssert() : exception-info ) as .pat: exception-info)
         -> std/core/types/True;
      (.pat0: exception-info)
         -> std/core/types/False;
    };
  };
inline fun is-exnTodo // inline size: 1
  = fn(exception-info: exception-info){
    match (exception-info) {
      ((std/core/ExnTodo() : exception-info ) as .pat: exception-info)
         -> std/core/types/True;
      (.pat0: exception-info)
         -> std/core/types/False;
    };
  };
inline fun is-exnRange // inline size: 1
  = fn(exception-info: exception-info){
    match (exception-info) {
      ((std/core/ExnRange() : exception-info ) as .pat: exception-info)
         -> std/core/types/True;
      (.pat0: exception-info)
         -> std/core/types/False;
    };
  };
inline fun is-exnPattern // inline size: 1
  = fn(exception-info: exception-info){
    match (exception-info) {
      ((std/core/ExnPattern((.pat0: std/core/types/string) : std/core/types/string, (.pat1: std/core/types/string) : std/core/types/string) : exception-info ) as .pat: exception-info)
         -> std/core/types/True;
      (.pat2: exception-info)
         -> std/core/types/False;
    };
  };
inline fun is-exnSystem // inline size: 1
  = fn(exception-info: exception-info){
    match (exception-info) {
      ((std/core/ExnSystem((.pat0: std/core/types/int) : std/core/types/int) : exception-info ) as .pat: exception-info)
         -> std/core/types/True;
      (.pat1: exception-info)
         -> std/core/types/False;
    };
  };
inline fun is-exnInternal // inline size: 1
  = fn(exception-info: exception-info){
    match (exception-info) {
      ((std/core/ExnInternal((.pat0: std/core/types/string) : std/core/types/string) : exception-info ) as .pat: exception-info)
         -> std/core/types/True;
      (.pat1: exception-info)
         -> std/core/types/False;
    };
  };
inline fun message // inline size: 0
  = fn(exception: exception){
    match (exception) {
      ((.skip std/core/Exception((.x: std/core/types/string) : std/core/types/string, (.pat0: exception-info) : exception-info) : exception ) as .pat: exception)
         -> .x;
    };
  };
inline fun info // inline size: 0
  = fn(exception: exception){
    match (exception) {
      ((.skip std/core/Exception((.pat0: std/core/types/string) : std/core/types/string, (.x: exception-info) : exception-info) : exception ) as .pat: exception)
         -> .x;
    };
  };
fun .copy // inline size: 3
  = fn(.this: exception, message0: (std/core/types/optional :: V -> V)<std/core/types/string>, info0: (std/core/types/optional :: V -> V)<exception-info>){
    std/core/Exception((match (message0) {
        ((std/core/types/Optional((.message.1690: std/core/types/string) : std/core/types/string) : (std/core/types/optional :: V -> V)<std/core/types/string> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/string>))
           -> .message.1690;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/string> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/string>))
           -> (match (.this) {
            ((.skip std/core/Exception((.x: std/core/types/string) : std/core/types/string, (.pat00: exception-info) : exception-info) : exception ) as .pat1: exception)
               -> .x;
          });
      }), (match (info0) {
        ((std/core/types/Optional((.info.1696: exception-info) : exception-info) : (std/core/types/optional :: V -> V)<exception-info> ) as .pat10: ((std/core/types/optional :: V -> V)<exception-info>))
           -> .info.1696;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<exception-info> ) as .pat2: ((std/core/types/optional :: V -> V)<exception-info>))
           -> (match (.this) {
            ((.skip std/core/Exception((.pat01: std/core/types/string) : std/core/types/string, (.x0: exception-info) : exception-info) : exception ) as .pat3: exception)
               -> .x0;
          });
      }));
  };
inline fun dref // inline size: 0
  = forall<(e :: E),a> fn(delayed: (delayed :: (E, V) -> V)<(e :: E),a>){
    (match (delayed) {
      ((.skip std/core/Delay((.x: (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>) : (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>) : (delayed :: (E, V) -> V)<(e :: E),a> ) as .pat: ((delayed :: (E, V) -> V)<(e :: E),a>))
         -> .x;
    });
  };
fun .copy.1 // inline size: 2
  = forall<(e :: E),a> fn(.this: (delayed :: (E, V) -> V)<(e :: E),a>, dref0: (std/core/types/optional :: V -> V)<(std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>>){
    std/core/Delay<(e :: E),a>((match (dref0) {
      ((std/core/types/Optional((.dref.1729: (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>) : (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>) : (std/core/types/optional :: V -> V)<(std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>> ) as .pat: ((std/core/types/optional :: V -> V)<(std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>>))
         -> .dref.1729;
      ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<(std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>> ) as .pat0: ((std/core/types/optional :: V -> V)<(std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>>))
         -> (match (.this) {
          ((.skip std/core/Delay((.x: (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>) : (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>) : (delayed :: (E, V) -> V)<(e :: E),a> ) as .pat1: ((delayed :: (E, V) -> V)<(e :: E),a>))
             -> .x;
        });
    }));
  };
inline fun is-error // inline size: 1
  = forall<a> fn(error: (error :: V -> V)<a>){
    (match (error) {
      ((std/core/Error(((.skip std/core/Exception((.pat1: std/core/types/string) : std/core/types/string, (.pat2: exception-info) : exception-info) : exception ) as .pat0: exception) : exception) : (error :: V -> V)<a> ) as .pat: ((error :: V -> V)<a>))
         -> std/core/types/True;
      (.pat3: ((error :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline fun is-ok // inline size: 1
  = forall<a> fn(error: (error :: V -> V)<a>){
    (match (error) {
      ((std/core/Ok((.pat0: a) : a) : (error :: V -> V)<a> ) as .pat: ((error :: V -> V)<a>))
         -> std/core/types/True;
      (.pat1: ((error :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline fun is-nil // inline size: 1
  = forall<a> fn(list0: (list :: V -> V)<a>){
    (match (list0) {
      ((std/core/Nil() : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/types/True;
      (.pat0: ((list :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline fun is-cons // inline size: 1
  = forall<a> fn(list0: (list :: V -> V)<a>){
    (match (list0) {
      ((std/core/Cons((.pat0: a) : a, (.pat1: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/types/True;
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat2: ((list :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline fun str // inline size: 0
  = fn(sslice: sslice){
    match (sslice) {
      ((.skip std/core/Sslice((.x: std/core/types/string) : std/core/types/string, (.pat0: std/core/types/ssize_t) : std/core/types/ssize_t, (.pat1: std/core/types/ssize_t) : std/core/types/ssize_t) : sslice ) as .pat: sslice)
         -> .x;
    };
  };
inline fun start // inline size: 0
  = fn(sslice: sslice){
    match (sslice) {
      ((.skip std/core/Sslice((.pat0: std/core/types/string) : std/core/types/string, (.x: std/core/types/ssize_t) : std/core/types/ssize_t, (.pat1: std/core/types/ssize_t) : std/core/types/ssize_t) : sslice ) as .pat: sslice)
         -> .x;
    };
  };
inline fun len // inline size: 0
  = fn(sslice: sslice){
    match (sslice) {
      ((.skip std/core/Sslice((.pat0: std/core/types/string) : std/core/types/string, (.pat1: std/core/types/ssize_t) : std/core/types/ssize_t, (.x: std/core/types/ssize_t) : std/core/types/ssize_t) : sslice ) as .pat: sslice)
         -> .x;
    };
  };
fun .copy.2 // inline size: 4
  = fn(.this: sslice, str0: (std/core/types/optional :: V -> V)<std/core/types/string>, start0: (std/core/types/optional :: V -> V)<std/core/types/ssize_t>, len0: (std/core/types/optional :: V -> V)<std/core/types/ssize_t>){
    std/core/Sslice((match (str0) {
        ((std/core/types/Optional((.str.1828: std/core/types/string) : std/core/types/string) : (std/core/types/optional :: V -> V)<std/core/types/string> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/string>))
           -> .str.1828;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/string> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/string>))
           -> (match (.this) {
            ((.skip std/core/Sslice((.x: std/core/types/string) : std/core/types/string, (.pat00: std/core/types/ssize_t) : std/core/types/ssize_t, (.pat10: std/core/types/ssize_t) : std/core/types/ssize_t) : sslice ) as .pat1: sslice)
               -> .x;
          });
      }), (match (start0) {
        ((std/core/types/Optional((.start.1834: std/core/types/ssize_t) : std/core/types/ssize_t) : (std/core/types/optional :: V -> V)<std/core/types/ssize_t> ) as .pat11: ((std/core/types/optional :: V -> V)<std/core/types/ssize_t>))
           -> .start.1834;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/ssize_t> ) as .pat2: ((std/core/types/optional :: V -> V)<std/core/types/ssize_t>))
           -> (match (.this) {
            ((.skip std/core/Sslice((.pat01: std/core/types/string) : std/core/types/string, (.x0: std/core/types/ssize_t) : std/core/types/ssize_t, (.pat12: std/core/types/ssize_t) : std/core/types/ssize_t) : sslice ) as .pat3: sslice)
               -> .x0;
          });
      }), (match (len0) {
        ((std/core/types/Optional((.len.1840: std/core/types/ssize_t) : std/core/types/ssize_t) : (std/core/types/optional :: V -> V)<std/core/types/ssize_t> ) as .pat30: ((std/core/types/optional :: V -> V)<std/core/types/ssize_t>))
           -> .len.1840;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/ssize_t> ) as .pat4: ((std/core/types/optional :: V -> V)<std/core/types/ssize_t>))
           -> (match (.this) {
            ((.skip std/core/Sslice((.pat02: std/core/types/string) : std/core/types/string, (.pat13: std/core/types/ssize_t) : std/core/types/ssize_t, (.x1: std/core/types/ssize_t) : std/core/types/ssize_t) : sslice ) as .pat5: sslice)
               -> .x1;
          });
      }));
  };
inline fun head // inline size: 0
  = forall<a> fn(stream: (stream :: V -> V)<a>){
    (match (stream) {
      ((.skip std/core/Next((.x: a) : a, (.pat0: (stream :: V -> V)<a>) : (stream :: V -> V)<a>) : (stream :: V -> V)<a> ) as .pat: ((stream :: V -> V)<a>))
         -> .x;
    });
  };
inline fun tail // inline size: 0
  = forall<a> fn(stream: (stream :: V -> V)<a>){
    (match (stream) {
      ((.skip std/core/Next((.pat0: a) : a, (.x: (stream :: V -> V)<a>) : (stream :: V -> V)<a>) : (stream :: V -> V)<a> ) as .pat: ((stream :: V -> V)<a>))
         -> .x;
    });
  };
fun .copy.3 // inline size: 3
  = forall<a> fn(.this: (stream :: V -> V)<a>, head0: (std/core/types/optional :: V -> V)<a>, tail0: (std/core/types/optional :: V -> V)<(stream :: V -> V)<a>>){
    std/core/Next<a>((match (head0) {
        ((std/core/types/Optional((.head.1886: a) : a) : (std/core/types/optional :: V -> V)<a> ) as .pat: ((std/core/types/optional :: V -> V)<a>))
           -> .head.1886;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<a> ) as .pat0: ((std/core/types/optional :: V -> V)<a>))
           -> (match (.this) {
            ((.skip std/core/Next((.x: a) : a, (.pat00: (stream :: V -> V)<a>) : (stream :: V -> V)<a>) : (stream :: V -> V)<a> ) as .pat1: ((stream :: V -> V)<a>))
               -> .x;
          });
      }), (match (tail0) {
        ((std/core/types/Optional((.tail.1893: (stream :: V -> V)<a>) : (stream :: V -> V)<a>) : (std/core/types/optional :: V -> V)<(stream :: V -> V)<a>> ) as .pat10: ((std/core/types/optional :: V -> V)<(stream :: V -> V)<a>>))
           -> .tail.1893;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<(stream :: V -> V)<a>> ) as .pat2: ((std/core/types/optional :: V -> V)<(stream :: V -> V)<a>>))
           -> (match (.this) {
            ((.skip std/core/Next((.pat01: a) : a, (.x0: (stream :: V -> V)<a>) : (stream :: V -> V)<a>) : (stream :: V -> V)<a> ) as .pat3: ((stream :: V -> V)<a>))
               -> .x0;
          });
      }));
  };
inline fun .select-throw-exn // inline size: 0
  = forall<a,(e :: E),b> fn(hnd: (.hnd-exn :: (E, V) -> V)<(e :: E),b>){
    (match (hnd) {
      ((.skip std/core/.Hnd-exn((brk-throw-exn: (forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exception,c,(.hnd-exn :: (E, V) -> V),(e :: E),b>)) : (forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exception,c,(.hnd-exn :: (E, V) -> V),(e :: E),b>)) : (.hnd-exn :: (E, V) -> V)<(e :: E),b> ) as .pat: ((.hnd-exn :: (E, V) -> V)<(e :: E),b>))
         -> brk-throw-exn<a>;
    });
  };
fun .new-sslice // inline size: 1
  = fn(str0: std/core/types/string, start0: std/core/types/ssize_t, len0: std/core/types/ssize_t){
    std/core/Sslice(str0, start0, len0);
  };
fun string.4 // inline size: 1
  = fn(ms: (std/core/types/maybe :: V -> V)<std/core/types/string>){
    match (ms) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<std/core/types/string> ) as .pat: ((std/core/types/maybe :: V -> V)<std/core/types/string>))
         -> "";
      ((.skip std/core/types/Just((s: std/core/types/string) : std/core/types/string) : (std/core/types/maybe :: V -> V)<std/core/types/string> ) as .pat0: ((std/core/types/maybe :: V -> V)<std/core/types/string>))
         -> s;
    };
  };
fun apply // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(f: (a) -> (e :: E) b, x: a){
    f(x);
  };
fun concat // inline size: 1
  = forall<a> fn(xss: (list :: V -> V)<(list :: V -> V)<a>>){
    std/core/.lift17262-concat<a>((std/core/Nil<a>), xss);
  };
inline fun const // inline size: 0
  = forall<a,b> fn(x: a, y: b){
    x;
  };
inline fun const.1 // inline size: 0
  = forall<a,b> fn<(total :: E)>(default0: a){
    fn(._wildcard_122_7: b){
      default0;
    };
  };
fun default // inline size: 1
  = forall<a> fn(m: (std/core/types/maybe :: V -> V)<a>, nothing: a){
    (match (m) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<a> ) as .pat: ((std/core/types/maybe :: V -> V)<a>))
         -> nothing;
      ((.skip std/core/types/Just((x: a) : a) : (std/core/types/maybe :: V -> V)<a> ) as .pat0: ((std/core/types/maybe :: V -> V)<a>))
         -> x;
    });
  };
fun default.1 // inline size: 1
  = forall<a> fn(t: (error :: V -> V)<a>, def: a){
    (match (t) {
      ((std/core/Error(((.skip std/core/Exception((.pat1: std/core/types/string) : std/core/types/string, (.pat2: exception-info) : exception-info) : exception ) as .pat0: exception) : exception) : (error :: V -> V)<a> ) as .pat: ((error :: V -> V)<a>))
         -> def;
      ((.skip std/core/Ok((x: a) : a) : (error :: V -> V)<a> ) as .pat3: ((error :: V -> V)<a>))
         -> x;
    });
  };
fun either // inline size: 3
  = forall<a> fn(t: (error :: V -> V)<a>){
    (match (t) {
      ((std/core/Error(((.skip std/core/Exception((.pat0: std/core/types/string) : std/core/types/string, (.pat1: exception-info) : exception-info) : exception ) as exn0: exception) : exception) : (error :: V -> V)<a> ) as .pat: ((error :: V -> V)<a>))
         -> std/core/types/Left<exception,a>(exn0);
      ((.skip std/core/Ok((x: a) : a) : (error :: V -> V)<a> ) as .pat2: ((error :: V -> V)<a>))
         -> std/core/types/Right<exception,a>(x);
    });
  };
fun flatmap // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, f: (a) -> (e :: E) (list :: V -> V)<b>){
    std/core/.lift17263-flatmap<a,b,(e :: E)>(f, (std/core/Nil<b>), xs);
  };
fun reverse-append // inline size: 1
  = forall<a> fn(xs: (list :: V -> V)<a>, tl: (list :: V -> V)<a>){
    std/core/.lift17264-reverse-append<a>(tl, xs);
  };
inline fun ignore // inline size: 0
  = forall<a> fn(x: a){
    std/core/types/();
  };
fun intersperse // inline size: 3
  = forall<a> fn(xs: (list :: V -> V)<a>, sep: a){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat1: ((list :: V -> V)<a>))
         -> std/core/Cons<a>(x, (std/core/.lift17265-intersperse<a>(xx, sep)));
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat2: ((list :: V -> V)<a>))
         -> std/core/Nil<a>;
    });
  };
fun is-even // inline size: 2
  = fn(i: std/core/types/int){
    val b.17095 : std/core/types/bool
          = std/core/is-odd(i);
    match (b.17095) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/False;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/core/types/True;
    };
  };
fun map-peek // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, f: (value : a, rest : (list :: V -> V)<a>) -> (e :: E) b){
    std/core/.lift17266-map-peek<a,b,(e :: E)>(f, xs);
  };
inline val maxListStack // inline size: 0
  = 50;
fun mbint // inline size: 1
  = fn(m: (std/core/types/maybe :: V -> V)<std/core/types/int>){
    match (m) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<std/core/types/int> ) as .pat: ((std/core/types/maybe :: V -> V)<std/core/types/int>))
         -> 0;
      ((.skip std/core/types/Just((i: std/core/types/int) : std/core/types/int) : (std/core/types/maybe :: V -> V)<std/core/types/int> ) as .pat0: ((std/core/types/maybe :: V -> V)<std/core/types/int>))
         -> i;
    };
  };
fun negate // inline size: 1
  = fn(i: std/core/types/int){
    std/core/(~)(i);
  };
fun o // inline size: 2
  = forall<a,b,c,(e :: E)> fn(f: (a) -> (e :: E) b, g: (c) -> (e :: E) a){
    fn<(e :: E)>(x: c){
      f((g(x)));
    };
  };
fun on-exit // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(hndler: () -> (e :: E) (), action: () -> (e :: E) a){
    std/core/hnd/finally<a,(e :: E)>(hndler, action);
  };
fun single // inline size: 1
  = forall<a> fn(x: a){
    std/core/Cons<a>(x, (std/core/Nil<a>));
  };
fun unsafe-nodiv // inline size: 2
  = forall<a,(e :: E)> fn<(e :: E)>(action: () -> <(std/core/types/div :: X)|(e :: E)> a){
    std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(action : () -> <(std/core/types/div :: X)|(e :: E)> a) -> a,(action : () -> <(std/core/types/div :: X)|(e :: E)> a) -> (e :: E) a>((std/core/types/unsafe-total<a,<(std/core/types/div :: X)|(e :: E)>>))(action);
  };
fun unsafe-noexn // inline size: 2
  = forall<a,(e :: E)> fn<(e :: E)>(action: () -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a){
    std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(action : () -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a) -> a,(action : () -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a) -> (e :: E) a>((std/core/types/unsafe-total<a,<(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)>>))(action);
  };
fun (-.4) // inline size: 4
  = fn<(total :: E)>(c: std/core/types/char, d: std/core/types/char){
    std/core/char((std/core/(-)((std/core/int(c)), (std/core/int(d)))));
  };
fun int.7 // inline size: 1
  = fn(b: std/core/types/bool){
    match (b) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> 1;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> 0;
    };
  };
fun int.8 // inline size: 3
  = fn(x: std/core/types/order){
    match (x) {
      ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
         -> std/core/(-)(0, 1);
      ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
         -> 0;
      ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
         -> 1;
    };
  };
fun (!=.5) // inline size: 2
  = fn(x: std/core/types/bool, y: std/core/types/bool){
    match (x) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> (match (y) {
          ((std/core/types/True() : std/core/types/bool ) as .pat0: std/core/types/bool)
             -> std/core/types/False;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat00: std/core/types/bool)
             -> std/core/types/True;
        });
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat01: std/core/types/bool)
         -> y;
    };
  };
fun (+.4) // inline size: 4
  = fn<(total :: E)>(c: std/core/types/char, d: std/core/types/char){
    std/core/char((std/core/(+)((std/core/int(c)), (std/core/int(d)))));
  };
fun (++) // inline size: 1
  = forall<a> fn(xs: (list :: V -> V)<a>, ys: (list :: V -> V)<a>){
    std/core/append<a>(xs, ys);
  };
fun (==.5) // inline size: 2
  = fn(x: std/core/types/bool, y: std/core/types/bool){
    match (x) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> y;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> (match (y) {
          ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/types/False;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat00: std/core/types/bool)
             -> std/core/types/True;
        });
    };
  };
fun (<.6) // inline size: 1
  = fn(x: std/core/types/bool, y: std/core/types/bool){
    match (x) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/False;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> y;
    };
  };
fun order // inline size: 4
  = fn(i: std/core/types/int){
    match ((std/core/(<.1)(i, 0))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/Lt;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> (match ((std/core/(>.1)(i, 0))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/types/Gt;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat2: std/core/types/bool)
             -> std/core/types/Eq;
        });
    };
  };
fun (>.4) // inline size: 2
  = fn(x: std/core/types/bool, y: std/core/types/bool){
    match (x) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> (match (y) {
          ((std/core/types/True() : std/core/types/bool ) as .pat0: std/core/types/bool)
             -> std/core/types/False;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat00: std/core/types/bool)
             -> std/core/types/True;
        });
      (.pat01: std/core/types/bool)
         -> std/core/types/False;
    };
  };
fun compare.1 // inline size: 4
  = fn(x: std/core/types/char, y: std/core/types/char){
    match ((std/core/(<)(x, y))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/Lt;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> (match ((std/core/(>)(x, y))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/types/Gt;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat2: std/core/types/bool)
             -> std/core/types/Eq;
        });
    };
  };
fun compare.3 // inline size: 4
  = fn(x: std/core/types/double, y: std/core/types/double){
    match ((std/core/(<.4)(x, y))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/Lt;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> (match ((std/core/(>.2)(x, y))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/types/Gt;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat2: std/core/types/bool)
             -> std/core/types/Eq;
        });
    };
  };
fun (>=.5) // inline size: 2
  = fn(x: std/core/types/bool, y: std/core/types/bool){
    match (x) {
      ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
         -> std/core/types/True;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat00: std/core/types/bool)
         -> (match (y) {
          ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
             -> std/core/types/False;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat02: std/core/types/bool)
             -> std/core/types/True;
        });
    };
  };
fun joinsep // inline size: 2
  = fn(xs: (list :: V -> V)<std/core/types/string>, sep: std/core/types/string){
    match (xs) {
      ((std/core/Nil() : (list :: V -> V)<std/core/types/string> ) as .pat1: ((list :: V -> V)<std/core/types/string>))
         -> "";
      ((.skip std/core/Cons((x: std/core/types/string) : std/core/types/string, (xx: (list :: V -> V)<std/core/types/string>) : (list :: V -> V)<std/core/types/string>) : (list :: V -> V)<std/core/types/string> ) as .pat2: ((list :: V -> V)<std/core/types/string>))
         -> std/core/.lift17267-joinsep(sep, xx, x);
    };
  };
fun join.2 // inline size: 2
  = fn(xs: (list :: V -> V)<std/core/types/string>){
    match (xs) {
      ((std/core/Nil() : (list :: V -> V)<std/core/types/string> ) as .pat1: ((list :: V -> V)<std/core/types/string>))
         -> "";
      ((.skip std/core/Cons((x: std/core/types/string) : std/core/types/string, (xx: (list :: V -> V)<std/core/types/string>) : (list :: V -> V)<std/core/types/string>) : (list :: V -> V)<std/core/types/string> ) as .pat2: ((list :: V -> V)<std/core/types/string>))
         -> std/core/.lift17268-join.2(xx, x);
    };
  };
fun join.3 // inline size: 1
  = fn(xs: (list :: V -> V)<std/core/types/string>, sep: std/core/types/string){
    std/core/joinsep(xs, sep);
  };
fun (<=.6) // inline size: 2
  = fn(x: std/core/types/bool, y: std/core/types/bool){
    match (x) {
      ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
         -> (match (y) {
          ((std/core/types/True() : std/core/types/bool ) as .pat2: std/core/types/bool)
             -> std/core/types/True;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat00: std/core/types/bool)
             -> std/core/types/False;
        });
      (.pat01: std/core/types/bool)
         -> std/core/types/True;
    };
  };
fun inc // inline size: 1
  = fn(i: std/core/types/int){
    std/core/(+)(i, 1);
  };
fun decr // inline size: 2
  = fn(i: std/core/types/int32){
    std/core/(-.1)(i, (std/core/int32(1)));
  };
fun incr // inline size: 2
  = fn(i: std/core/types/int32){
    std/core/(+.1)(i, (std/core/int32(1)));
  };
fun forz // inline size: 1
  = forall<(e :: E)> fn<(e :: E)>(start0: std/core/types/ssize_t, end: std/core/types/ssize_t, action: (std/core/types/ssize_t) -> (e :: E) ()){
    std/core/.lift17269-forz<(e :: E)>(action, end, start0);
  };
fun length.1 // inline size: 1
  = forall<a> fn(xs: (list :: V -> V)<a>){
    std/core/.lift17270-length.1<a>(xs, 0);
  };
fun length.2 // inline size: 2
  = forall<a> fn(v: (std/core/types/vector :: V -> V)<a>){
    std/core/int.2((std/core/lengthz<a>(v)));
  };
fun list.4 // inline size: 4
  = fn<(total :: E)>(lo: std/core/types/char, hi: std/core/types/char){
    std/core/map.5<std/core/types/int,std/core/types/char,(total :: E)>((std/core/list((std/core/int(lo)), (std/core/int(hi)))), std/core/char);
  };
fun list.5 // inline size: 2
  = forall<a> fn(m: (std/core/types/maybe :: V -> V)<a>){
    (match (m) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<a> ) as .pat: ((std/core/types/maybe :: V -> V)<a>))
         -> std/core/Nil<a>;
      ((.skip std/core/types/Just((x: a) : a) : (std/core/types/maybe :: V -> V)<a> ) as .pat0: ((std/core/types/maybe :: V -> V)<a>))
         -> std/core/Cons<a>(x, (std/core/Nil<a>));
    });
  };
fun list.7 // inline size: 1
  = forall<a> fn(v: (std/core/types/vector :: V -> V)<a>){
    std/core/vlist<a>(v, (std/core/types/None<(list :: V -> V)<a>>));
  };
fun map // inline size: 3
  = forall<a,b,(e :: E)> fn<(e :: E)>(m: (std/core/types/maybe :: V -> V)<a>, f: (a) -> (e :: E) b){
    (match (m) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<a> ) as .pat: ((std/core/types/maybe :: V -> V)<a>))
         -> std/core/types/Nothing<b>;
      ((.skip std/core/types/Just((x: a) : a) : (std/core/types/maybe :: V -> V)<a> ) as .pat0: ((std/core/types/maybe :: V -> V)<a>))
         -> std/core/types/Just<b>((f(x)));
    });
  };
fun map.1 // inline size: 4
  = forall<a,b,c,(e :: E)> fn<(e :: E)>(e: (std/core/types/either :: (V, V) -> V)<a,b>, f: (b) -> (e :: E) c){
    (match (e) {
      ((std/core/types/Right((x: b) : b) : (std/core/types/either :: (V, V) -> V)<a,b> ) as .pat: ((std/core/types/either :: (V, V) -> V)<a,b>))
         -> std/core/types/Right<a,c>((f(x)));
      ((.skip std/core/types/Left((x0: a) : a) : (std/core/types/either :: (V, V) -> V)<a,b> ) as .pat0: ((std/core/types/either :: (V, V) -> V)<a,b>))
         -> std/core/types/Left<a,c>(x0);
    });
  };
fun sign.1 // inline size: 4
  = fn(d: std/core/types/double){
    match ((std/core/(<.4)(d, 0.0))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/Lt;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> (match ((std/core/(>.2)(d, 0.0))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/types/Gt;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat2: std/core/types/bool)
             -> std/core/types/Eq;
        });
    };
  };
fun is-pos.3 // inline size: 1
  = fn(d: std/core/types/double){
    std/core/(>.2)(d, 0.0);
  };
fun is-empty // inline size: 1
  = forall<a> fn(xs: (list :: V -> V)<a>){
    (match (xs) {
      ((std/core/Nil() : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/types/True;
      (.pat0: ((list :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
fun is-empty.1 // inline size: 2
  = fn(slice0: sslice){
    val b.17134 : std/core/types/bool
          = std/core/is-pos.1((match (slice0) {
            ((.skip std/core/Sslice((.pat00: std/core/types/string) : std/core/types/string, (.pat10: std/core/types/ssize_t) : std/core/types/ssize_t, (.x: std/core/types/ssize_t) : std/core/types/ssize_t) : sslice ) as .pat1: sslice)
               -> .x;
          }));
    match (b.17134) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/False;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/core/types/True;
    };
  };
fun is-empty.2 // inline size: 1
  = fn(s: std/core/types/string){
    std/core/(==.3)(s, "");
  };
fun (||) // inline size: 1
  = forall<a> fn(m1: (std/core/types/maybe :: V -> V)<a>, m2: (std/core/types/maybe :: V -> V)<a>){
    (match (m1) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<a> ) as .pat: ((std/core/types/maybe :: V -> V)<a>))
         -> m2;
      (.pat0: ((std/core/types/maybe :: V -> V)<a>))
         -> m1;
    });
  };
fun (||.1) // inline size: 2
  = fn(x: std/core/types/string, y: std/core/types/string){
    match ((std/core/(==.3)(x, ""))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> y;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> x;
    };
  };
fun show-exp // inline size: 3
  = fn(d: std/core/types/double, precision: (std/core/types/optional :: V -> V)<std/core/types/int>){
    std/core/show-expx(d, (std/core/int32((match (precision) {
        ((std/core/types/Optional((.precision.8139: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> .precision.8139;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> -17;
      }))));
  };
inline fun show.10 // inline size: 0
  = fn(exn0: exception){
    match (exn0) {
      ((.skip std/core/Exception((.x: std/core/types/string) : std/core/types/string, (.pat0: exception-info) : exception-info) : exception ) as .pat: exception)
         -> .x;
    };
  };
fun show.2 // inline size: 3
  = fn(c: std/core/types/char){
    std/core/(++.1)("\x27", (std/core/(++.1)((std/core/show-char(c)), "\x27")));
  };
fun show.4 // inline size: 1
  = fn(b: std/core/types/bool){
    match (b) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> "True";
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> "False";
    };
  };
inline fun show.5 // inline size: 0
  = fn(u: ()){
    "()";
  };
fun show.6 // inline size: 2
  = fn(s: sslice){
    std/core/show.3((std/core/string.3(s)));
  };
fun show.7 // inline size: 1
  = fn(xs: (list :: V -> V)<std/core/types/string>){
    std/core/show-list<std/core/types/string,(std/core/types/(<>) :: E)>(xs, std/core/show.3);
  };
fun show.8 // inline size: 1
  = fn(xs: (list :: V -> V)<std/core/types/int>){
    std/core/show-list<std/core/types/int,(std/core/types/(<>) :: E)>(xs, std/core/show);
  };
fun show.9 // inline size: 1
  = fn(xs: (list :: V -> V)<std/core/types/bool>){
    std/core/show-list<std/core/types/bool,(std/core/types/(<>) :: E)>(xs, std/core/show.4);
  };
fun println // inline size: 1
  = fn<<(console :: X)>>(s: std/core/types/string){
    std/core/printsln(s);
  };
fun println.1 // inline size: 2
  = fn<<(console :: X)>>(i: std/core/types/int){
    std/core/printsln((std/core/show(i)));
  };
fun println.2 // inline size: 2
  = fn<<(console :: X)>>(d: std/core/types/double){
    std/core/printsln((std/core/show.1(d, (std/core/types/None<std/core/types/int>))));
  };
fun println.3 // inline size: 2
  = fn<<(console :: X)>>(b: std/core/types/bool){
    std/core/printsln((match (b) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> "True";
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> "False";
    }));
  };
fun println.4 // inline size: 2
  = fn<<(console :: X)>>(c: std/core/types/char){
    std/core/printsln((std/core/string(c)));
  };
fun println.5 // inline size: 1
  = fn<<(console :: X)>>(u: ()){
    std/core/printsln("()");
  };
inline fun throw-exn // inline size: 5
  = forall<a> fn<<(std/core/types/handled :: HX -> X)<(exn :: HX)>>>(exn0: exception){
    std/core/hnd/.perform1<exception,a,<(std/core/types/handled :: HX -> X)<(exn :: HX)>>,(.hnd-exn :: (E, V) -> V)>((std/core/types/.open<(std/core/types/(<>) :: E),<(std/core/types/handled :: HX -> X)<(exn :: HX)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(.hnd-exn :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(.hnd-exn :: (E, V) -> V)>>((std/core/hnd/.evv-at<(.hnd-exn :: (E, V) -> V)>))((std/core/types/.open<(std/core/types/(<>) :: E),<(std/core/types/handled :: HX -> X)<(exn :: HX)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>> std/core/types/ssize_t>(std/core/ssize_t)(0)))), (forall<(e :: E),b> std/core/.select-throw-exn<a,(e :: E),b>), exn0);
  };
fun (^.1) // inline size: 1
  = fn(i: std/core/types/int, exp: std/core/types/int){
    std/core/pow(i, exp);
  };
fun assert // inline size: 2
  = fn(message0: std/core/types/string, condition: std/core/types/bool){
    match (condition) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/();
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/core/unsafe-assert-fail(message0);
    };
  };
fun before // inline size: 2
  = fn(slice0: sslice){
    match (slice0) {
      ((.skip std/core/Sslice((s: std/core/types/string) : std/core/types/string, (start0: std/core/types/ssize_t) : std/core/types/ssize_t, (.pat0: std/core/types/ssize_t) : std/core/types/ssize_t) : sslice ) as .pat: sslice)
         -> std/core/Sslice(s, (std/core/ssize_t(0)), start0);
    };
  };
fun bool // inline size: 1
  = fn(i: std/core/types/int){
    std/core/(!=.1)(i, 0);
  };
fun bool.1 // inline size: 1
  = forall<a> fn(m: (std/core/types/maybe :: V -> V)<a>){
    (match (m) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<a> ) as .pat: ((std/core/types/maybe :: V -> V)<a>))
         -> std/core/types/False;
      (.pat0: ((std/core/types/maybe :: V -> V)<a>))
         -> std/core/types/True;
    });
  };
fun bool.2 // inline size: 1
  = fn(s: std/core/types/string){
    std/core/(!=.3)(s, "");
  };
fun catch // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(action: () -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a, hndl: (exception) -> (e :: E) a){
    std/core/try<a,(e :: E)>(action, hndl);
  };
fun for-whilez // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(start0: std/core/types/ssize_t, end: std/core/types/ssize_t, action: (std/core/types/ssize_t) -> (e :: E) (std/core/types/maybe :: V -> V)<a>){
    std/core/.lift17273-for-whilez<a,(e :: E)>(action, end, start0);
  };
fun slice // inline size: 3
  = fn(s: std/core/types/string){
    std/core/Sslice(s, (std/core/ssize_t(0)), (std/core/length(s)));
  };
fun foreach.1 // inline size: 2
  = forall<(e :: E)> fn<(e :: E)>(slice0: sslice, action: (c : std/core/types/char) -> (e :: E) ()){
    val _0 : (std/core/types/maybe :: V -> V)<_a>
          = std/core/foreach-while.1<_a,(e :: E)>(slice0, (fn<(e :: E)>(c: std/core/types/char){
              val _ : ()
                    = (action(c));
              (std/core/types/Nothing<_a>);
            }));
    std/core/types/();
  };
fun foreach.3 // inline size: 2
  = forall<a,(e :: E)> fn<(e :: E)>(v: (std/core/types/vector :: V -> V)<a>, f: (a) -> (e :: E) ()){
    std/core/foreach-indexedz<a,(e :: E)>(v, (fn<(e :: E)>(x: a, ._wildcard_2142_28: std/core/types/ssize_t){
        (f(x));
      }));
  };
fun dec // inline size: 1
  = fn(i: std/core/types/int){
    std/core/(-)(i, 1);
  };
fun exp10 // inline size: 1
  = fn(exp: std/core/types/int){
    std/core/mul-exp10(1, exp);
  };
fun is-neg.3 // inline size: 1
  = fn(d: std/core/types/double){
    std/core/(<.4)(d, 0.0);
  };
fun exn // inline size: 1
  = forall<a> fn<<(std/core/types/handled :: HX -> X)<(exn :: HX)>>>(err: (error :: V -> V)<a>){
    std/core/throw.1<a>(err);
  };
fun exp2 // inline size: 1
  = fn(exp: std/core/types/int){
    std/core/pow(2, exp);
  };
fun is-zero.2 // inline size: 1
  = fn(d: std/core/types/double){
    std/core/(==.2)(d, 0.0);
  };
fun find // inline size: 4
  = forall<a> fn(xs: (list :: V -> V)<a>, pred: (a) -> std/core/types/bool){
    std/core/foreach-while<a,a,(std/core/types/(<>) :: E)>(xs, (fn(x: a){
        (match ((pred(x))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
             -> std/core/types/Just<a>(x);
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
             -> std/core/types/Nothing<a>;
        });
      }));
  };
fun find-maybe // inline size: 1
  = forall<a,b> fn(xs: (list :: V -> V)<a>, pred: (a) -> (std/core/types/maybe :: V -> V)<b>){
    std/core/foreach-while<a,b,(std/core/types/(<>) :: E)>(xs, pred);
  };
fun fold-int.1 // inline size: 4
  = forall<a,(e :: E)> fn<(e :: E)>(upto: std/core/types/int, init0: a, f: (std/core/types/int, a) -> (e :: E) a){
    std/core/fold-int<a,(e :: E)>(0, (std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(i : std/core/types/int) -> std/core/types/int,(i : std/core/types/int) -> (e :: E) std/core/types/int>((fn(i: std/core/types/int){
        (std/core/(-)(i, 1));
      }))(upto)), init0, f);
  };
fun foldl1 // inline size: 4
  = forall<a,(e :: E)> fn<<(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)>>(xs: (list :: V -> V)<a>, f: (a, a) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/foldl<a,a,<(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)>>(xx, x, f);
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat0: ((list :: V -> V)<a>))
         -> std/core/types/.open<<(std/core/types/handled :: HX -> X)<(exn :: HX)>>,<(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)>,(message : std/core/types/string, info : (std/core/types/optional :: V -> V)<exception-info>) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>> a,(message : std/core/types/string, info : (std/core/types/optional :: V -> V)<exception-info>) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a>((std/core/throw<a>))("unexpected Nil in std/core/foldl1", (std/core/types/None<exception-info>));
    });
  };
fun reverse // inline size: 1
  = forall<a> fn(xs: (list :: V -> V)<a>){
    std/core/.lift17274-reverse<a>((std/core/Nil<a>), xs);
  };
fun foldr // inline size: 4
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, z: b, f: (a, b) -> (e :: E) b){
    std/core/foldl<a,b,(e :: E)>((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(xs : (list :: V -> V)<a>) -> (list :: V -> V)<a>,(xs : (list :: V -> V)<a>) -> (e :: E) (list :: V -> V)<a>>((std/core/reverse<a>))(xs)), z, (fn<(e :: E)>(x: b, y: a){
        (f(y, x));
      }));
  };
fun for // inline size: 1
  = forall<(e :: E)> fn<(e :: E)>(start0: std/core/types/int, end: std/core/types/int, action: (std/core/types/int) -> (e :: E) ()){
    std/core/.lift17275-for<(e :: E)>(action, end, start0);
  };
fun for-while // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(start0: std/core/types/int, end: std/core/types/int, action: (std/core/types/int) -> (e :: E) (std/core/types/maybe :: V -> V)<a>){
    std/core/.lift17276-for-while<a,(e :: E)>(action, end, start0);
  };
fun foreach-indexed.1 // inline size: 4
  = forall<a,(e :: E)> fn<(e :: E)>(v: (std/core/types/vector :: V -> V)<a>, f: (a, std/core/types/int) -> (e :: E) ()){
    std/core/foreach-indexedz<a,(e :: E)>(v, (fn<(e :: E)>(x: a, i: std/core/types/ssize_t){
        (f(x, (std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(i : std/core/types/ssize_t) -> std/core/types/int,(i : std/core/types/ssize_t) -> (e :: E) std/core/types/int>(std/core/int.2)(i))));
      }));
  };
fun print // inline size: 1
  = fn<<(console :: X)>>(s: std/core/types/string){
    std/core/prints(s);
  };
fun print.1 // inline size: 2
  = fn<<(console :: X)>>(i: std/core/types/int){
    std/core/prints((std/core/show(i)));
  };
fun print.2 // inline size: 2
  = fn<<(console :: X)>>(d: std/core/types/double){
    std/core/prints((std/core/show.1(d, (std/core/types/None<std/core/types/int>))));
  };
fun print.3 // inline size: 2
  = fn<<(console :: X)>>(b: std/core/types/bool){
    std/core/prints((match (b) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> "True";
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> "False";
    }));
  };
fun print.4 // inline size: 2
  = fn<<(console :: X)>>(c: std/core/types/char){
    std/core/prints((std/core/string(c)));
  };
fun print.5 // inline size: 1
  = fn<<(console :: X)>>(u: ()){
    std/core/prints("()");
  };
fun gprint // inline size: 2
  = forall<a> fn<<(console :: X)>>(x: a){
    val s.17184 : std/core/types/string
          = std/core/gshow<a>(x);
    std/core/prints(s.17184);
  };
fun gprintln // inline size: 2
  = forall<a> fn<<(console :: X)>>(x: a){
    val s.17185 : std/core/types/string
          = std/core/gshow<a>(x);
    std/core/printsln(s.17185);
  };
fun head.1 // inline size: 2
  = forall<a> fn(xs: (list :: V -> V)<a>){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (.pat0: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/types/Just<a>(x);
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat1: ((list :: V -> V)<a>))
         -> std/core/types/Nothing<a>;
    });
  };
fun head.2 // inline size: 1
  = forall<a> fn(xs: (list :: V -> V)<a>, default0: a){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (.pat0: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> x;
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat1: ((list :: V -> V)<a>))
         -> default0;
    });
  };
fun head-char // inline size: 4
  = fn(s: std/core/types/string){
    std/core/foreach-while.1<std/core/types/char,(std/core/types/(<>) :: E)>((std/core/Sslice(s, (std/core/ssize_t(0)), (std/core/length(s)))), (std/core/types/Just<std/core/types/char>));
  };
fun index-of // inline size: 1
  = forall<a> fn(xs: (list :: V -> V)<a>, pred: (a) -> std/core/types/bool){
    std/core/index-of-acc<a>(xs, pred, 0);
  };
fun is-lower // inline size: 3
  = fn(c: std/core/types/char){
    match ((std/core/(>=)(c, 'a'))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/(<=)(c, 'z');
      (.pat0: std/core/types/bool)
         -> std/core/types/False;
    };
  };
fun is-upper // inline size: 3
  = fn(c: std/core/types/char){
    match ((std/core/(>=)(c, 'A'))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/(<=)(c, 'Z');
      (.pat0: std/core/types/bool)
         -> std/core/types/False;
    };
  };
fun is-digit // inline size: 3
  = fn(c: std/core/types/char){
    match ((std/core/(>=)(c, '0'))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/(<=)(c, '9');
      (.pat0: std/core/types/bool)
         -> std/core/types/False;
    };
  };
fun is-ascii // inline size: 1
  = fn(c: std/core/types/char){
    std/core/(<=)(c, '\x7F');
  };
fun is-control // inline size: 1
  = fn(c: std/core/types/char){
    std/core/(<)(c, ' ');
  };
fun is-notempty // inline size: 1
  = fn(slice0: sslice){
    std/core/is-pos.1((match (slice0) {
      ((.skip std/core/Sslice((.pat0: std/core/types/string) : std/core/types/string, (.pat1: std/core/types/ssize_t) : std/core/types/ssize_t, (.x: std/core/types/ssize_t) : std/core/types/ssize_t) : sslice ) as .pat: sslice)
         -> .x;
    }));
  };
fun is-notempty.1 // inline size: 1
  = fn(s: std/core/types/string){
    std/core/(!=.3)(s, "");
  };
fun is-valid // inline size: 2
  = fn(slice0: sslice){
    std/core/(>=.2)((match (slice0) {
        ((.skip std/core/Sslice((.pat0: std/core/types/string) : std/core/types/string, (.x: std/core/types/ssize_t) : std/core/types/ssize_t, (.pat1: std/core/types/ssize_t) : std/core/types/ssize_t) : sslice ) as .pat: sslice)
           -> .x;
      }), (std/core/ssize_t(0)));
  };
fun join-end // inline size: 3
  = fn(xs: (list :: V -> V)<std/core/types/string>, end: std/core/types/string){
    match (xs) {
      ((std/core/Nil() : (list :: V -> V)<std/core/types/string> ) as .pat: ((list :: V -> V)<std/core/types/string>))
         -> "";
      (.pat0: ((list :: V -> V)<std/core/types/string>))
         -> std/core/(++.1)((std/core/joinsep(xs, end)), end);
    };
  };
fun split // inline size: 3
  = forall<a> fn(xs: (list :: V -> V)<a>, n: std/core/types/int){
    std/core/types/(,)<(list :: V -> V)<a>,(list :: V -> V)<a>>((std/core/take<a>(xs, n)), (std/core/drop<a>(xs, n)));
  };
fun split.1 // inline size: 2
  = fn(s: std/core/types/string, sep: std/core/types/string){
    val v.17196 : (std/core/types/vector :: V -> V)<std/core/types/string>
          = std/core/splitv(s, sep);
    std/core/vlist<std/core/types/string>(v.17196, (std/core/types/None<(list :: V -> V)<std/core/types/string>>));
  };
fun split.2 // inline size: 3
  = fn(s: std/core/types/string, sep: std/core/types/string, n: std/core/types/int){
    val v.17197 : (std/core/types/vector :: V -> V)<std/core/types/string>
          = std/core/splitv.1(s, sep, (std/core/ssize_t(n)));
    std/core/vlist<std/core/types/string>(v.17197, (std/core/types/None<(list :: V -> V)<std/core/types/string>>));
  };
fun lines // inline size: 2
  = fn(s: std/core/types/string){
    val v.17200 : (std/core/types/vector :: V -> V)<std/core/types/string>
          = std/core/splitv(s, "\x0A");
    std/core/vlist<std/core/types/string>(v.17200, (std/core/types/None<(list :: V -> V)<std/core/types/string>>));
  };
fun lookup // inline size: 4
  = forall<a,b> fn(xs: (list :: V -> V)<(a, b)>, pred: (a) -> std/core/types/bool){
    std/core/foreach-while<(a, b),b,(std/core/types/(<>) :: E)>(xs, (fn(kv: (a, b)){
        (match ((pred((match (kv) {
          ((.skip std/core/types/(,)((.x: a) : a, (.pat0: b) : b) : (a, b) ) as .pat: (a, b))
             -> .x;
        })))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/types/Just<b>((match (kv) {
              ((.skip std/core/types/(,)((.pat00: a) : a, (.x0: b) : b) : (a, b) ) as .pat2: (a, b))
                 -> .x0;
            }));
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat01: std/core/types/bool)
             -> std/core/types/Nothing<b>;
        });
      }));
  };
fun map-indexed // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, f: (idx : std/core/types/int, value : a) -> (e :: E) b){
    std/core/.lift17277-map-indexed<a,b,(e :: E)>(f, xs, 0);
  };
fun map-indexed-peek // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, f: (idx : std/core/types/int, value : a, rest : (list :: V -> V)<a>) -> (e :: E) b){
    std/core/.lift17278-map-indexed-peek<a,b,(e :: E)>(f, xs, 0);
  };
fun max // inline size: 2
  = fn(i: std/core/types/int, j: std/core/types/int){
    match ((std/core/(>=.1)(i, j))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> i;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> j;
    };
  };
fun max.1 // inline size: 2
  = fn(x: std/core/types/double, y: std/core/types/double){
    match ((std/core/(>=.3)(x, y))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> x;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> y;
    };
  };
fun maximum // inline size: 3
  = fn(xs: (list :: V -> V)<std/core/types/int>, default0: (std/core/types/optional :: V -> V)<std/core/types/int>){
    match (xs) {
      ((std/core/Nil() : (list :: V -> V)<std/core/types/int> ) as .pat1: ((list :: V -> V)<std/core/types/int>))
         -> (match (default0) {
          ((std/core/types/Optional((.default.14461: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/int>))
             -> .default.14461;
          ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/int>))
             -> 0;
        });
      ((.skip std/core/Cons((x: std/core/types/int) : std/core/types/int, (xx: (list :: V -> V)<std/core/types/int>) : (list :: V -> V)<std/core/types/int>) : (list :: V -> V)<std/core/types/int> ) as .pat2: ((list :: V -> V)<std/core/types/int>))
         -> std/core/foldl<std/core/types/int,std/core/types/int,(std/core/types/(<>) :: E)>(xx, x, std/core/max);
    };
  };
fun maximum.1 // inline size: 2
  = fn(xs: (list :: V -> V)<std/core/types/double>){
    match (xs) {
      ((std/core/Nil() : (list :: V -> V)<std/core/types/double> ) as .pat: ((list :: V -> V)<std/core/types/double>))
         -> 0.0;
      ((.skip std/core/Cons((x: std/core/types/double) : std/core/types/double, (xx: (list :: V -> V)<std/core/types/double>) : (list :: V -> V)<std/core/types/double>) : (list :: V -> V)<std/core/types/double> ) as .pat0: ((list :: V -> V)<std/core/types/double>))
         -> std/core/foldl<std/core/types/double,std/core/types/double,(std/core/types/(<>) :: E)>(xx, x, std/core/max.1);
    };
  };
fun maybe // inline size: 2
  = forall<a,b,(e :: E)> fn<(e :: E)>(m: (std/core/types/maybe :: V -> V)<a>, onNothing: b, onJust: (a) -> (e :: E) b){
    (match (m) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<a> ) as .pat: ((std/core/types/maybe :: V -> V)<a>))
         -> onNothing;
      ((.skip std/core/types/Just((x: a) : a) : (std/core/types/maybe :: V -> V)<a> ) as .pat0: ((std/core/types/maybe :: V -> V)<a>))
         -> onJust(x);
    });
  };
fun maybe.1 // inline size: 1
  = forall<a> fn(m: (std/core/types/maybe :: V -> V)<a>, nothing: a){
    (match (m) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<a> ) as .pat: ((std/core/types/maybe :: V -> V)<a>))
         -> nothing;
      ((.skip std/core/types/Just((x: a) : a) : (std/core/types/maybe :: V -> V)<a> ) as .pat0: ((std/core/types/maybe :: V -> V)<a>))
         -> x;
    });
  };
fun maybe.2 // inline size: 2
  = forall<a,b> fn(e: (std/core/types/either :: (V, V) -> V)<a,b>){
    (match (e) {
      ((std/core/types/Left((.pat0: a) : a) : (std/core/types/either :: (V, V) -> V)<a,b> ) as .pat: ((std/core/types/either :: (V, V) -> V)<a,b>))
         -> std/core/types/Nothing<b>;
      ((.skip std/core/types/Right((x: b) : b) : (std/core/types/either :: (V, V) -> V)<a,b> ) as .pat1: ((std/core/types/either :: (V, V) -> V)<a,b>))
         -> std/core/types/Just<b>(x);
    });
  };
fun maybe.3 // inline size: 2
  = forall<a> fn(xs: (list :: V -> V)<a>){
    (match (xs) {
      ((std/core/Nil() : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/types/Nothing<a>;
      ((.skip std/core/Cons((x: a) : a, (.pat1: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat0: ((list :: V -> V)<a>))
         -> std/core/types/Just<a>(x);
    });
  };
fun maybe.4 // inline size: 2
  = fn(b: std/core/types/bool){
    match (b) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/Just<()>(std/core/types/());
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/core/types/Nothing<()>;
    };
  };
fun maybe.5 // inline size: 3
  = fn(i: std/core/types/int){
    match ((std/core/(==.1)(i, 0))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/Nothing<std/core/types/int>;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/core/types/Just<std/core/types/int>(i);
    };
  };
fun maybe.6 // inline size: 3
  = fn(s: std/core/types/string){
    match ((std/core/(==.3)(s, ""))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/Nothing<std/core/types/string>;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/core/types/Just<std/core/types/string>(s);
    };
  };
fun maybe.7 // inline size: 2
  = forall<a> fn(t: (error :: V -> V)<a>){
    (match (t) {
      ((std/core/Error(((.skip std/core/Exception((.pat1: std/core/types/string) : std/core/types/string, (.pat2: exception-info) : exception-info) : exception ) as .pat0: exception) : exception) : (error :: V -> V)<a> ) as .pat: ((error :: V -> V)<a>))
         -> std/core/types/Nothing<a>;
      ((.skip std/core/Ok((x: a) : a) : (error :: V -> V)<a> ) as .pat3: ((error :: V -> V)<a>))
         -> std/core/types/Just<a>(x);
    });
  };
fun min // inline size: 2
  = fn(i: std/core/types/int, j: std/core/types/int){
    match ((std/core/(<=.1)(i, j))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> i;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> j;
    };
  };
fun min.1 // inline size: 2
  = fn(x: std/core/types/double, y: std/core/types/double){
    match ((std/core/(<=.4)(x, y))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> x;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> y;
    };
  };
fun minimum // inline size: 3
  = fn(xs: (list :: V -> V)<std/core/types/int>, default0: (std/core/types/optional :: V -> V)<std/core/types/int>){
    match (xs) {
      ((std/core/Nil() : (list :: V -> V)<std/core/types/int> ) as .pat1: ((list :: V -> V)<std/core/types/int>))
         -> (match (default0) {
          ((std/core/types/Optional((.default.14940: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/int>))
             -> .default.14940;
          ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/int>))
             -> 0;
        });
      ((.skip std/core/Cons((x: std/core/types/int) : std/core/types/int, (xx: (list :: V -> V)<std/core/types/int>) : (list :: V -> V)<std/core/types/int>) : (list :: V -> V)<std/core/types/int> ) as .pat2: ((list :: V -> V)<std/core/types/int>))
         -> std/core/foldl<std/core/types/int,std/core/types/int,(std/core/types/(<>) :: E)>(xx, x, std/core/min);
    };
  };
fun minimum.1 // inline size: 2
  = fn(xs: (list :: V -> V)<std/core/types/double>){
    match (xs) {
      ((std/core/Nil() : (list :: V -> V)<std/core/types/double> ) as .pat: ((list :: V -> V)<std/core/types/double>))
         -> 0.0;
      ((.skip std/core/Cons((x: std/core/types/double) : std/core/types/double, (xx: (list :: V -> V)<std/core/types/double>) : (list :: V -> V)<std/core/types/double>) : (list :: V -> V)<std/core/types/double> ) as .pat0: ((list :: V -> V)<std/core/types/double>))
         -> std/core/foldl<std/core/types/double,std/core/types/double,(std/core/types/(<>) :: E)>(xx, x, std/core/min.1);
    };
  };
fun null.1 // inline size: 4
  = fn(i: std/core/types/int){
    std/core/null<std/core/types/int>((match ((std/core/(==.1)(i, 0))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/Nothing<std/core/types/int>;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/core/types/Just<std/core/types/int>(i);
    }));
  };
fun null.2 // inline size: 4
  = fn(s: std/core/types/string){
    std/core/null<std/core/types/string>((match ((std/core/(==.3)(s, ""))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/Nothing<std/core/types/string>;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/core/types/Just<std/core/types/string>(s);
    }));
  };
fun null.3 // inline size: 3
  = fn(b: std/core/types/bool){
    std/core/null<()>((match (b) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/Just<()>(std/core/types/());
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/core/types/Nothing<()>;
    }));
  };
fun trim // inline size: 2
  = fn(s: std/core/types/string){
    std/core/trim-right((std/core/trim-left(s)));
  };
fun parse-int // inline size: 4
  = fn(s: std/core/types/string, hex: (std/core/types/optional :: V -> V)<std/core/types/bool>){
    std/core/xparse-int((std/core/trim-right((std/core/trim-left(s)))), (match (hex) {
        ((std/core/types/Optional((.hex.15612: std/core/types/bool) : std/core/types/bool) : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
           -> .hex.15612;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
           -> std/core/types/False;
      }));
  };
fun partition // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool){
    std/core/partition-acc<a,(e :: E)>(xs, pred, (std/core/Nil<a>), (std/core/Nil<a>));
  };
fun remove // inline size: 3
  = forall<a> fn(xs: (list :: V -> V)<a>, pred: (a) -> std/core/types/bool){
    std/core/filter<a,(std/core/types/(<>) :: E)>(xs, (fn(x: a){
        val b.17221 : std/core/types/bool
              = (pred(x));
        (match (b.17221) {
          ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
             -> std/core/types/False;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
             -> std/core/types/True;
        });
      }));
  };
fun repeat // inline size: 2
  = fn(s: std/core/types/string, n: std/core/types/int){
    std/core/repeatz(s, (std/core/ssize_t(n)));
  };
fun repeat.1 // inline size: 2
  = forall<(e :: E)> fn<(e :: E)>(n: std/core/types/int, action: () -> (e :: E) ()){
    std/core/for<(e :: E)>(1, n, (fn<(e :: E)>(i: std/core/types/int){
        (action());
      }));
  };
fun reverse-join // inline size: 3
  = fn(xs: (list :: V -> V)<std/core/types/string>){
    val xs0.17223 : (list :: V -> V)<std/core/types/string>
          = std/core/.lift17279-reverse-join<std/core/types/string>((std/core/Nil<std/core/types/string>), xs);
    match (xs0.17223) {
      ((std/core/Nil() : (list :: V -> V)<std/core/types/string> ) as .pat10: ((list :: V -> V)<std/core/types/string>))
         -> "";
      ((.skip std/core/Cons((x0: std/core/types/string) : std/core/types/string, (xx0: (list :: V -> V)<std/core/types/string>) : (list :: V -> V)<std/core/types/string>) : (list :: V -> V)<std/core/types/string> ) as .pat2: ((list :: V -> V)<std/core/types/string>))
         -> std/core/.lift17280-reverse-join(xx0, x0);
    };
  };
fun span // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    std/core/.lift17281-span<a,(e :: E)>(predicate, xs, (std/core/Nil<a>));
  };
fun sum // inline size: 2
  = fn(xs: (list :: V -> V)<std/core/types/int>){
    std/core/foldl<std/core/types/int,std/core/types/int,(std/core/types/(<>) :: E)>(xs, 0, (fn(x: std/core/types/int, y: std/core/types/int){
        (std/core/(+)(x, y));
      }));
  };
fun tail.1 // inline size: 1
  = forall<a> fn(xs: (list :: V -> V)<a>){
    (match (xs) {
      ((std/core/Cons((.pat0: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> xx;
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat1: ((list :: V -> V)<a>))
         -> std/core/Nil<a>;
    });
  };
fun unlines // inline size: 2
  = fn(xs: (list :: V -> V)<std/core/types/string>){
    match (xs) {
      ((std/core/Nil() : (list :: V -> V)<std/core/types/string> ) as .pat1: ((list :: V -> V)<std/core/types/string>))
         -> "";
      ((.skip std/core/Cons((x: std/core/types/string) : std/core/types/string, (xx: (list :: V -> V)<std/core/types/string>) : (list :: V -> V)<std/core/types/string>) : (list :: V -> V)<std/core/types/string> ) as .pat2: ((list :: V -> V)<std/core/types/string>))
         -> std/core/.lift17282-unlines(xx, x);
    };
  };
fun unzip // inline size: 1
  = forall<a,b> fn(xs: (list :: V -> V)<(a, b)>){
    std/core/.lift17283-unzip<a,b>(xs, (std/core/Nil<a>), (std/core/Nil<b>));
  };
fun vector.2 // inline size: 2
  = forall<a> fn(n: std/core/types/int, default0: a){
    std/core/vector-initz<a>((std/core/ssize_t(n)), (fn(._wildcard_2118_30: std/core/types/ssize_t){
        default0;
      }));
  };
fun vector.3 // inline size: 1
  = forall<a> fn(xs: (list :: V -> V)<a>){
    std/core/unvlist<a>(xs);
  };
fun vector-init // inline size: 4
  = forall<a> fn(n: std/core/types/int, f: (std/core/types/int) -> a){
    std/core/vector-initz<a>((std/core/ssize_t(n)), (fn(i: std/core/types/ssize_t){
        (f((std/core/int.2(i))));
      }));
  };
fun zipwith-indexed // inline size: 1
  = forall<a,b,c,(e :: E)> fn<(e :: E)>(xs0: (list :: V -> V)<a>, ys0: (list :: V -> V)<b>, f: (std/core/types/int, a, b) -> (e :: E) c){
    std/core/.lift17286-zipwith-indexed<a,b,c,(e :: E)>(f, 0, xs0, ys0);
  };
recursive specialize "__*" fun list.2 // inline size: 11
  = forall<a,(e :: E)> fn<(e :: E)>(lo: std/core/types/int, hi: std/core/types/int, f: (std/core/types/int) -> (e :: E) a){
    (match ((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : std/core/types/int, y : std/core/types/int) -> std/core/types/bool,(x : std/core/types/int, y : std/core/types/int) -> (e :: E) std/core/types/bool>(std/core/(<=.1))(lo, hi))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/Cons<a>((f(lo)), (std/core/list.2<a,(e :: E)>((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : std/core/types/int) -> std/core/types/int,(x : std/core/types/int) -> (e :: E) std/core/types/int>((std/core/types/unsafe-decreasing<std/core/types/int>))((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(i : std/core/types/int) -> std/core/types/int,(i : std/core/types/int) -> (e :: E) std/core/types/int>((fn(i: std/core/types/int){
              (std/core/(+)(i, 1));
            }))(lo)))), hi, f)));
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/core/Nil<a>;
    });
  };
recursive specialize "___*" fun list.3 // inline size: 10
  = forall<a,(e :: E)> fn<(e :: E)>(lo: std/core/types/int, hi: std/core/types/int, stride: std/core/types/int, f: (std/core/types/int) -> (e :: E) a){
    (match ((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : std/core/types/int, y : std/core/types/int) -> std/core/types/bool,(x : std/core/types/int, y : std/core/types/int) -> (e :: E) std/core/types/bool>(std/core/(<=.1))(lo, hi))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/Cons<a>((f(lo)), (std/core/list.3<a,(e :: E)>((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : std/core/types/int) -> std/core/types/int,(x : std/core/types/int) -> (e :: E) std/core/types/int>((std/core/types/unsafe-decreasing<std/core/types/int>))((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(std/core/types/int, std/core/types/int) -> std/core/types/int,(std/core/types/int, std/core/types/int) -> (e :: E) std/core/types/int>(std/core/(+))(lo, stride)))), hi, stride, f)));
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/core/Nil<a>;
    });
  };
recursive specialize "_*" fun map.5 // inline size: 4
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, f: (a) -> (e :: E) b){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/Cons<b>((f(x)), (std/core/map.5<a,b,(e :: E)>(xx, f)));
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat0: ((list :: V -> V)<a>))
         -> std/core/Nil<b>;
    });
  };
recursive specialize "_*" fun all // inline size: 4
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> (match ((predicate(x))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat0: std/core/types/bool)
             -> std/core/all<a,(e :: E)>(xx, predicate);
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/types/False;
        });
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat2: ((list :: V -> V)<a>))
         -> std/core/types/True;
    });
  };
recursive specialize "_*" fun any // inline size: 4
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> (match ((predicate(x))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat0: std/core/types/bool)
             -> std/core/types/True;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/any<a,(e :: E)>(xx, predicate);
        });
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat2: ((list :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
recursive specialize "_*" fun foreach-while // inline size: 4
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, action: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    (match (xs) {
      ((std/core/Nil() : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/types/Nothing<b>;
      ((.skip std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat0: ((list :: V -> V)<a>))
         -> (match ((action(x))) {
          ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<b> ) as .pat1: ((std/core/types/maybe :: V -> V)<b>))
             -> std/core/foreach-while<a,b,(e :: E)>(xx, action);
          (just: ((std/core/types/maybe :: V -> V)<b>))
             -> just;
        });
    });
  };
recursive specialize "_*" fun foreach-while.1 // inline size: 8
  = forall<a,(e :: E)> fn<(e :: E)>(slice0: sslice, action: (c : std/core/types/char) -> (e :: E) (std/core/types/maybe :: V -> V)<a>){
    (match ((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(slice : sslice) -> (std/core/types/maybe :: V -> V)<(std/core/types/char, sslice)>,(slice : sslice) -> (e :: E) (std/core/types/maybe :: V -> V)<(std/core/types/char, sslice)>>(std/core/next)(slice0))) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<(std/core/types/char, sslice)> ) as .pat: ((std/core/types/maybe :: V -> V)<(std/core/types/char, sslice)>))
         -> std/core/types/Nothing<a>;
      ((.skip std/core/types/Just(((.skip std/core/types/(,)((c: std/core/types/char) : std/core/types/char, ((.skip std/core/Sslice((.pat2: std/core/types/string) : std/core/types/string, (.pat3: std/core/types/ssize_t) : std/core/types/ssize_t, (.pat4: std/core/types/ssize_t) : std/core/types/ssize_t) : sslice ) as rest: sslice) : sslice) : (std/core/types/char, sslice) ) as .pat1: (std/core/types/char, sslice)) : (std/core/types/char, sslice)) : (std/core/types/maybe :: V -> V)<(std/core/types/char, sslice)> ) as .pat0: ((std/core/types/maybe :: V -> V)<(std/core/types/char, sslice)>))
         -> (match ((action(c))) {
          ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<a> ) as .pat5: ((std/core/types/maybe :: V -> V)<a>))
             -> std/core/foreach-while.1<a,(e :: E)>((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : sslice) -> sslice,(x : sslice) -> (e :: E) sslice>((std/core/types/unsafe-decreasing<sslice>))(rest)), action);
          (res: ((std/core/types/maybe :: V -> V)<a>))
             -> res;
        });
    });
  };
recursive specialize "_*" fun foreach // inline size: 3
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, action: (a) -> (e :: E) ()){
    (match (xs) {
      ((std/core/Nil() : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/types/();
      ((.skip std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat0: ((list :: V -> V)<a>))
         -> val _ : ()
                  = action(x);
        std/core/foreach<a,(e :: E)>(xx, action);
    });
  };
recursive specialize "_*" fun drop-while // inline size: 4
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> (match ((predicate(x))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat0: std/core/types/bool)
             -> std/core/drop-while<a,(e :: E)>(xx, predicate);
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> xs;
        });
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat2: ((list :: V -> V)<a>))
         -> std/core/Nil<a>;
    });
  };
recursive specialize "_*" fun filter // inline size: 6
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> (match ((pred(x))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat0: std/core/types/bool)
             -> std/core/Cons<a>(x, (std/core/filter<a,(e :: E)>(xx, pred)));
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/filter<a,(e :: E)>(xx, pred);
        });
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat2: ((list :: V -> V)<a>))
         -> std/core/Nil<a>;
    });
  };
recursive specialize "_*" fun filter-map // inline size: 6
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, pred: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    (match (xs) {
      ((std/core/Nil() : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/Nil<b>;
      ((.skip std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat0: ((list :: V -> V)<a>))
         -> (match ((pred(x))) {
          ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<b> ) as .pat1: ((std/core/types/maybe :: V -> V)<b>))
             -> std/core/filter-map<a,b,(e :: E)>(xx, pred);
          ((.skip std/core/types/Just((y: b) : b) : (std/core/types/maybe :: V -> V)<b> ) as .pat2: ((std/core/types/maybe :: V -> V)<b>))
             -> std/core/Cons<b>(y, (std/core/filter-map<a,b,(e :: E)>(xx, pred)));
        });
    });
  };
recursive specialize "_*" fun flatmap-maybe // inline size: 6
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, f: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> (match ((f(x))) {
          ((std/core/types/Just((y: b) : b) : (std/core/types/maybe :: V -> V)<b> ) as .pat0: ((std/core/types/maybe :: V -> V)<b>))
             -> std/core/Cons<b>(y, (std/core/flatmap-maybe<a,b,(e :: E)>(xx, f)));
          ((.skip std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<b> ) as .pat1: ((std/core/types/maybe :: V -> V)<b>))
             -> std/core/flatmap-maybe<a,b,(e :: E)>(xx, f);
        });
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat2: ((list :: V -> V)<a>))
         -> std/core/Nil<b>;
    });
  };
recursive specialize "___*" fun fold-int // inline size: 10
  = forall<a,(e :: E)> fn<(e :: E)>(start0: std/core/types/int, end: std/core/types/int, init0: a, f: (std/core/types/int, a) -> (e :: E) a){
    (match ((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : std/core/types/int, y : std/core/types/int) -> std/core/types/bool,(x : std/core/types/int, y : std/core/types/int) -> (e :: E) std/core/types/bool>(std/core/(>=.1))(start0, end))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> init0;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> val x : a
                  = f(start0, init0);
        std/core/fold-int<a,(e :: E)>((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : std/core/types/int) -> std/core/types/int,(x : std/core/types/int) -> (e :: E) std/core/types/int>((std/core/types/unsafe-decreasing<std/core/types/int>))((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(i : std/core/types/int) -> std/core/types/int,(i : std/core/types/int) -> (e :: E) std/core/types/int>((fn(i: std/core/types/int){
            (std/core/(+)(i, 1));
          }))(start0)))), end, x, f);
    });
  };
recursive specialize "__*" fun foldl // inline size: 3
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, z: b, f: (b, a) -> (e :: E) b){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/foldl<a,b,(e :: E)>(xx, (f(z, x)), f);
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat0: ((list :: V -> V)<a>))
         -> z;
    });
  };
recursive specialize "_*_" fun index-of-acc // inline size: 6
  = forall<a> fn(xs: (list :: V -> V)<a>, pred: (a) -> std/core/types/bool, idx: std/core/types/int){
    (match (xs) {
      ((std/core/Nil() : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/(-)(0, 1);
      ((.skip std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat0: ((list :: V -> V)<a>))
         -> (match ((pred(x))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> idx;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat2: std/core/types/bool)
             -> std/core/index-of-acc<a>(xx, pred, (std/core/(+)(idx, 1)));
        });
    });
  };
recursive specialize "_*" fun map-while // inline size: 5
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, action: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    (match (xs) {
      ((std/core/Nil() : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/Nil<b>;
      ((.skip std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat0: ((list :: V -> V)<a>))
         -> (match ((action(x))) {
          ((std/core/types/Just((y: b) : b) : (std/core/types/maybe :: V -> V)<b> ) as .pat1: ((std/core/types/maybe :: V -> V)<b>))
             -> std/core/Cons<b>(y, (std/core/map-while<a,b,(e :: E)>(xx, action)));
          ((.skip std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<b> ) as .pat2: ((std/core/types/maybe :: V -> V)<b>))
             -> std/core/Nil<b>;
        });
    });
  };
recursive specialize "_*__" fun partition-acc // inline size: 12
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool, acc1: (list :: V -> V)<a>, acc2: (list :: V -> V)<a>){
    (match (xs) {
      ((std/core/Nil() : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/types/(,)<(list :: V -> V)<a>,(list :: V -> V)<a>>((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(xs : (list :: V -> V)<a>) -> (list :: V -> V)<a>,(xs : (list :: V -> V)<a>) -> (e :: E) (list :: V -> V)<a>>((std/core/reverse<a>))(acc1)), (std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(xs : (list :: V -> V)<a>) -> (list :: V -> V)<a>,(xs : (list :: V -> V)<a>) -> (e :: E) (list :: V -> V)<a>>((std/core/reverse<a>))(acc2)));
      ((.skip std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat0: ((list :: V -> V)<a>))
         -> (match ((pred(x))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/partition-acc<a,(e :: E)>(xx, pred, (std/core/Cons<a>(x, acc1)), acc2);
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat2: std/core/types/bool)
             -> std/core/partition-acc<a,(e :: E)>(xx, pred, acc1, (std/core/Cons<a>(x, acc2)));
        });
    });
  };
recursive specialize "_*" fun take-while // inline size: 5
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> (match ((predicate(x))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat0: std/core/types/bool)
             -> std/core/Cons<a>(x, (std/core/take-while<a,(e :: E)>(xx, predicate)));
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/Nil<a>;
        });
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat2: ((list :: V -> V)<a>))
         -> std/core/Nil<a>;
    });
  };
recursive specialize "**" fun while // inline size: 4
  = forall<(e :: E)> fn<<(std/core/types/div :: X)|(e :: E)>>(predicate: () -> <(std/core/types/div :: X)|(e :: E)> std/core/types/bool, action: () -> <(std/core/types/div :: X)|(e :: E)> ()){
    (match ((predicate())) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> val _ : ()
                  = action();
        std/core/while<(e :: E)>(predicate, action);
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/core/types/();
    });
  };
recursive specialize "__*" fun zipwith // inline size: 5
  = forall<a,b,c,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, ys: (list :: V -> V)<b>, f: (a, b) -> (e :: E) c){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> (match (ys) {
          ((std/core/Cons((y: b) : b, (yy: (list :: V -> V)<b>) : (list :: V -> V)<b>) : (list :: V -> V)<b> ) as .pat0: ((list :: V -> V)<b>))
             -> std/core/Cons<c>((f(x, y)), (std/core/zipwith<a,b,c,(e :: E)>(xx, yy, f)));
          ((.skip std/core/Nil() : (list :: V -> V)<b> ) as .pat1: ((list :: V -> V)<b>))
             -> std/core/Nil<c>;
        });
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat2: ((list :: V -> V)<a>))
         -> std/core/Nil<c>;
    });
  };
recursive specialize "*____" fun zipwith-acc // inline size: 11
  = forall<a,b,c,(e :: E)> fn<(e :: E)>(f: (std/core/types/int, a, b) -> (e :: E) c, i: std/core/types/int, acc: (list :: V -> V)<c>, xs: (list :: V -> V)<a>, ys: (list :: V -> V)<b>){
    (match (xs) {
      ((std/core/Nil() : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(xs : (list :: V -> V)<c>) -> (list :: V -> V)<c>,(xs : (list :: V -> V)<c>) -> (e :: E) (list :: V -> V)<c>>((std/core/reverse<c>))(acc);
      ((.skip std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat0: ((list :: V -> V)<a>))
         -> (match (ys) {
          ((std/core/Nil() : (list :: V -> V)<b> ) as .pat1: ((list :: V -> V)<b>))
             -> std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(xs : (list :: V -> V)<c>) -> (list :: V -> V)<c>,(xs : (list :: V -> V)<c>) -> (e :: E) (list :: V -> V)<c>>((std/core/reverse<c>))(acc);
          ((.skip std/core/Cons((y: b) : b, (yy: (list :: V -> V)<b>) : (list :: V -> V)<b>) : (list :: V -> V)<b> ) as .pat2: ((list :: V -> V)<b>))
             -> std/core/zipwith-acc<a,b,c,(e :: E)>(f, (std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(std/core/types/int, std/core/types/int) -> std/core/types/int,(std/core/types/int, std/core/types/int) -> (e :: E) std/core/types/int>(std/core/(+))(i, 1)), (std/core/Cons<c>((f(i, x, y)), acc)), xx, yy);
        });
    });
  };