module interface operators
 
//------------------------------
//#kki: import declarations
 
private import std/core/types = std/core/types = "";
private import std/core = std/core = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
infixl 30 (?);
infixr 30 (::);
 
//------------------------------
//#kki: local imported aliases
 
 
//------------------------------
//#kki: type declarations
 
 
//------------------------------
//#kki: declarations
 
// List construction (note that literals can be created with [,] syntax, but this is poorly documented)
public fun (::) : forall<a> (a : a, ls : (std/core/list :: V -> V)<a>) -> (std/core/list :: V -> V)<a>;
public fun (::.1) : forall<a> (a : a, b : a) -> (std/core/list :: V -> V)<a>;
// Currying
public fun (?) : forall<a,(e :: E),b> (h : (a) -> (e :: E) b, a : a) -> (e :: E) b;
public fun (?.1) : forall<a,b,(e :: E),c> (h : (a, b) -> (e :: E) c, a : a) -> ((b) -> (e :: E) c);
public fun (?.2) : forall<a,b,c,(e :: E),d> (h : (a, b, c) -> (e :: E) d, a : a) -> ((b, c) -> (e :: E) d);
public fun (?.3) : forall<a,b,c,d,(e :: E),a1> (h : (a, b, c, d) -> (e :: E) a1, a : a) -> ((b, c, d) -> (e :: E) a1);
public fun (?.4) : forall<a,b,c,d,a1,(e :: E),b1> (h : (a, b, c, d, a1) -> (e :: E) b1, a : a) -> ((b, c, d, a1) -> (e :: E) b1);
public fun (?.5) : forall<a,b,c,d,a1,b1,(e :: E),c1> (h : (a, b, c, d, a1, b1) -> (e :: E) c1, a : a) -> ((b, c, d, a1, b1) -> (e :: E) c1);
public fun (?.6) : forall<a,b,c,d,a1,b1,c1,(e :: E),d1> (h : (a, b, c, d, a1, b1, c1) -> (e :: E) d1, a : a) -> ((b, c, d, a1, b1, c1) -> (e :: E) d1);
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
fun (::) // inline size: 1
  = forall<a> fn(a: a, ls: (std/core/list :: V -> V)<a>){
    std/core/Cons<a>(a, ls);
  };
fun (::.1) // inline size: 2
  = forall<a> fn(a: a, b: a){
    std/core/Cons<a>(a, (std/core/Cons<a>(b, (std/core/Nil<a>))));
  };
fun (?) // inline size: 1
  = forall<a,(e :: E),b> fn<(e :: E)>(h: (a) -> (e :: E) b, a: a){
    h(a);
  };
fun (?.1) // inline size: 1
  = forall<a,b,(e :: E),c> fn(h: (a, b) -> (e :: E) c, a: a){
    fn<(e :: E)>(b: b){
      h(a, b);
    };
  };
fun (?.2) // inline size: 1
  = forall<a,b,c,(e :: E),d> fn(h: (a, b, c) -> (e :: E) d, a: a){
    fn<(e :: E)>(b: b, c: c){
      h(a, b, c);
    };
  };
fun (?.3) // inline size: 1
  = forall<a,b,c,d,(e :: E),a1> fn(h: (a, b, c, d) -> (e :: E) a1, a: a){
    fn<(e :: E)>(b: b, c: c, d: d){
      h(a, b, c, d);
    };
  };
fun (?.4) // inline size: 1
  = forall<a,b,c,d,a1,(e :: E),b1> fn(h: (a, b, c, d, a1) -> (e :: E) b1, a: a){
    fn<(e :: E)>(b: b, c: c, d: d, e: a1){
      h(a, b, c, d, e);
    };
  };
fun (?.5) // inline size: 1
  = forall<a,b,c,d,a1,b1,(e :: E),c1> fn(h: (a, b, c, d, a1, b1) -> (e :: E) c1, a: a){
    fn<(e :: E)>(b: b, c: c, d: d, e: a1, f: b1){
      h(a, b, c, d, e, f);
    };
  };
fun (?.6) // inline size: 1
  = forall<a,b,c,d,a1,b1,c1,(e :: E),d1> fn(h: (a, b, c, d, a1, b1, c1) -> (e :: E) d1, a: a){
    fn<(e :: E)>(b: b, c: c, d: d, e: a1, f: b1, g: c1){
      h(a, b, c, d, e, f, g);
    };
  };